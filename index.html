<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name='yandex-verification' content='4a3e9fdb2ed97f52' />

  <title>
    
      Главная &middot; MrDekk
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/css/mrdekk.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Noto+Serif:400,400italic,700,700italic&subset=latin,cyrillic-ext,latin-ext,cyrillic'>
  <link rel="stylesheet" href="/public/css/font-awesome.min.css" >

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  <link rel="stylesheet" href="/public/css/tabs.css">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
	  <img class="profile" alt="my-profile" src="/media/images/brujo.jpg" width="120px">
      <h1>MrDekk</h1>
      <p class="description">Время - лучший учитель! Жаль, что оно убивает своих учеников...</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="/"><i class="fa fa-home" ></i></a>
      </li>

      

      
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/about/">Кто здесь?</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
          
        
      
        
      
        
      
        
          
        
      
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/tags/">Метки</a>
            </li>
          
        
      
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/useful/">Полезное</a>
            </li>
          
        
      
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/awesome/">Awesome Stars</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
    </ul>

	<p class="social-icons">
		<!-- <a href="/search"><i class="fa fa-search fa-2x"></i></a> -->
		<a href="https://github.com/mrdekk"><i class="fa fa-github fa-2x"></i></a>
		<a href="https://twitter.com/mrdekk"><i class="fa fa-twitter fa-2x"></i></a>
		<a href="/atom.xml"><i class="fa fa-rss fa-2x"></i></a>
	</p>

    <p>&copy; 2025. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2025/10/24/on-component/">
        Баллада о компоненте
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">24.10.2025</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#architecture" title="Pages tagged architecture" rel="tag" class="text-success">architecture</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82" title="Pages tagged компонент" rel="tag" class="text-success">компонент</a>
        </div>
        
      
    </p>

    <p>В последнее время веду много архитектурных дискуссий, и в их рамках часто возникает необходимость определить некоторые элементы в системе и задать правила взаимодействия этих элементов. Чаще всего это делается через картинку с квадратиками и стрелочками между ними. Однако за этими квадратиками и стрелочками часто кроется недосказанность, которая потом проявляется при разработке или даже при эксплуатации системы.</p>

<p>Поэтому важно думать об этих квадратиках каким-то образом, чтобы эти недосказанности видеть в процессе проектирования или даже использовать их в проектировании. В своей работе я часто пользуюсь абстракцией компонента и предлагаю ее окружающим. В ходе этих предложений приходится про компонент рассказывать детально. Поэтому я решил написать эту статью, в которую поместить все те мысли, которые я произношу, чтобы был материал, во-первых, написанный, а во-вторых, доступный для чтения желающим.</p>

<p>Вот она, баллада о компоненте</p>

<h2 id="что-такое-компонент">Что такое компонент?</h2>

<p>Для начала определим, что такое собственно компонент, обычно я даю такую картинку:</p>

<p><img src="/media/images/arch/basic_component.jpg" alt="компонент" /></p>

<p>Если говорить нестрого, то <strong>компонент - это некоторая сущность, имеющая некоторое назначение и решающая какую-то одну задачу</strong>. Если задач несколько - то скорее всего мы имеем дело с несколькими компонентами и надо подумать над декомпозицией. К компоненту, уже по определению, применяется принцип <a href="https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности">SRP</a>.</p>

<p>Для того, чтобы обсуждение было более наглядным, возьмем пример. Будем рассматривать такой компонент, как бариста.</p>

<blockquote>
  <p>У баристы есть назначение - он готовит кофе.</p>
</blockquote>

<p>Однако, чтобы выполнить свое предназначение, любому компоненту нужны связи с внешним миром (с другими компонентами). Можно выделить четыре вида связи:</p>

<ul>
  <li><strong>Входные данные</strong> - набор входных условий, на основании которых компонент делает свою работу. Для нашего примера с баристой - входными данными являются заказы клиентов.</li>
  <li><strong>Выходные данные</strong> - набор выходных артефактов, которые являются результатом деятельности компонента. Для примера с баристой - это чашка кофе по конкретному заказу клиента.</li>
  <li><strong>Зависимости</strong> - ресурсы, артефакты, данные, которые использует компонент, чтобы преобразовывать входные данные в выходные. Для примера с баристой - это зерна кофе, вода, электричество, молоко и т.д.</li>
  <li><strong>Конфигурация</strong> - специальные управляющие воздействия на то, как компонент делает свою работу. Для примера с баристой - это, например, меню от руководства, задающее доступные для заказа и приготовления напитки (т.е. например, даже если у нас есть молоко для капучино, мы можем намеренно его не готовить).</li>
</ul>

<p>Для большего понимания, рассмотрим пример кода с баристой:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ClientAsk</span> <span class="p">{</span>
	<span class="kd">enum</span> <span class="kt">CoffeeKinds</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">americano</span>
		<span class="k">case</span> <span class="n">cappuccino</span>
		<span class="c1">// the rest ...</span>
	<span class="p">}</span>

	<span class="k">let</span> <span class="nv">coffeeKind</span><span class="p">:</span> <span class="kt">CoffeeKinds</span>
	<span class="k">let</span> <span class="nv">withSugar</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">Barista</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="k">let</span> <span class="nv">dependencies</span><span class="p">:</span> <span class="kt">BaristaDependencies</span>
	<span class="kd">private</span> <span class="k">let</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">Menu</span>

	<span class="nf">init</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="kt">BaristaDependencies</span><span class="p">,</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">Menu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">self</span><span class="o">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="n">dependencies</span>
		<span class="k">self</span><span class="o">.</span><span class="n">menu</span> <span class="o">=</span> <span class="n">menu</span>
	<span class="p">}</span>

	<span class="kd">func</span> <span class="nf">makeCoffee</span><span class="p">(</span><span class="nv">ask</span><span class="p">:</span> <span class="kt">ClientAsk</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">Cup</span><span class="p">,</span> <span class="kt">BaristaErrors</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="c1">// use dependencies and menu to process client ask and make a cup of coffee</span>
		<span class="c1">// or report and error</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>В данном случае</p>

<ul>
  <li>Входные данные: ClientAsk, сущность, описывающая заказ клиента. Это то, что принимает компонент для одной итерации своей работы.</li>
  <li>Выходные данные: Result&lt;Cup, Error&gt;, тут стоит отметить важный факт, что результатом работы компонента может быть:
    <ul>
      <li>успешное выполнение своих обязанностей, и тогда результатом этого будет некоторый артефакт (в нашем случае Cup) этой работы</li>
      <li>или сигнал о том, что работа в обычном виде выполнена быть не может (в нашем случае BaristaErrors), артефакт, описывающий причины того, почему работа не может быть сделана или почему не удалось ее выполнить (важно не забывать про эту часть)</li>
    </ul>
  </li>
  <li>Зависимости: Dependencies, тут все что необходимо для приготовления чашечки кофе из заказа клиента</li>
  <li>Конфигурация: Menu, описывает виды кофе, которые можно сегодня приготовить</li>
</ul>

<h2 id="зачем-нам-компонент">Зачем нам компонент?</h2>

<p>С концепцией компонента разобрались, если будут вопросы - пишите, дополню статью. Теперь более насущный вопрос, а зачем нам компонент? Здесь надо сделать небольшое лирическое отступление.</p>

<p>Перед разработкой любой программной системы и при добавлении новой функциональности в уже имеющуюся, необходимо хорошо продумать что и как мы будем делать. Обычно я даже прошу написать что-то вроде <a href="https://ru.wikipedia.org/wiki/RFC">RFC</a>, в котором было бы явно описано что и как. Но чтобы разобраться что и как мы хотим делать (и даже написать RFC), необходимо к этому продумыванию как-то подойти. Декомпозировать задачу (которая, на самом деле, редко бывает сформулирована формально) на составляющие и обозначить между ними связи. А если система уже имеется, то еще и “прицепить” новую “запчасть” к тем что уже есть, ничего не забыть и сделать это правильно. И если мы будем мыслить систему в виде взаимодействующих друг с другом компонентов, то у нас будет хорошее подспорье к тому, чтобы задачу проектирования решить успешно.</p>

<p>К тому же, компоненты - фрактальны. Т.е. можно сделать несколько уровней не только в контексте кто кому предоставляет конфигурацию и зависимости, но и кто из кого состоит. Таким образом на одном уровне абстракции компонент может быть одним кубиком, а на другом - графом взаимодействующих друг с другом более низкоуровневых компонент.</p>

<p>Вернемся к нашему баристе, для пользователя это своего рода черных ящик - мы ему заказ, он нам чашечку кофе (или ошибку, не забываем!). Однако, если вы как клиент постоите и посмотрите на работу баристы, то заметите, что чашка кофе - результат последовательности действий. И таким образом компонент “Бариста” состоял бы из сети компонентов, в который входили бы: кофемолка, кофемашина, мойка для чашей, и т.д.</p>

<p>Поэтому компонент дает нам удобную абстракцию для анализа систем и синтеза решений.</p>

<h2 id="класс-как-компонент">Класс как компонент</h2>

<p>Вооружившись абстракцией компонента, давайте посмотрим на привычные конструкции из программирования. Любой класс можно рассматривать как компонент. Вернемся к примеру с баристой выше</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">ClientAsk</span> <span class="p">{</span>
	<span class="kd">enum</span> <span class="kt">CoffeeKinds</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">americano</span>
		<span class="k">case</span> <span class="n">capuccino</span>
		<span class="c1">// the rest ...</span>
	<span class="p">}</span>

	<span class="k">let</span> <span class="nv">coffeeKind</span><span class="p">:</span> <span class="kt">CoffeeKinds</span>
	<span class="k">let</span> <span class="nv">withSugar</span><span class="p">:</span> <span class="kt">Bool</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">BaristaDependencies</span> <span class="p">{</span>
	<span class="k">var</span> <span class="nv">grinder</span><span class="p">:</span> <span class="kt">Grinder</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
	<span class="k">var</span> <span class="nv">coffeeMachine</span><span class="p">:</span> <span class="kt">CoffeeMachine</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
	<span class="k">var</span> <span class="nv">waterTap</span><span class="p">:</span> <span class="kt">WaterTap</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
	<span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">Menu</span> <span class="p">{</span>
	<span class="k">var</span> <span class="nv">isCappuccinoAllowed</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
	<span class="c1">// ...</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">Barista</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="k">let</span> <span class="nv">dependencies</span><span class="p">:</span> <span class="kt">BaristaDependencies</span>
	<span class="kd">private</span> <span class="k">let</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">Menu</span>

	<span class="nf">init</span><span class="p">(</span><span class="nv">dependencies</span><span class="p">:</span> <span class="kt">BaristaDependencies</span><span class="p">,</span> <span class="nv">menu</span><span class="p">:</span> <span class="kt">Menu</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">self</span><span class="o">.</span><span class="n">dependencies</span> <span class="o">=</span> <span class="n">dependencies</span>
		<span class="k">self</span><span class="o">.</span><span class="n">menu</span> <span class="o">=</span> <span class="n">menu</span>
	<span class="p">}</span>

	<span class="kd">func</span> <span class="nf">makeCoffee</span><span class="p">(</span><span class="nv">ask</span><span class="p">:</span> <span class="kt">ClientAsk</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Result</span><span class="o">&lt;</span><span class="kt">Cup</span><span class="p">,</span> <span class="kt">BaristaErrors</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="c1">// use dependencies and menu to process client ask and make a cup of coffee</span>
		<span class="c1">// or report and error</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Как я уже выше писал - это типичный компонент. Но давайте посмотрим на другие входящие в пример вещи. Является ли ClientAsk компонентом? А Cup? А BaristaDependencies? А Menu?</p>

<p>Интуиция подсказывает что скорее нет, ведь это всего лишь DTO (Data Transfer Object). Но это впечатление обманчиво - это тоже компоненты.</p>

<ul>
  <li>ClientAsk и Cup это действительно DTO, объекты, чье единственное предназначение - перенос данных. Таким образом их входные и выходные данные хранятся напрямую в их полях и идентичны. Хотя порой такое бывает не всегда, и даже простые DTO могут на вход получать данные в одном виде, а на выходе давать в другом.</li>
  <li>BaristaDependencies как мы видим лишь контракт, который может скрывать в себе как просто прокси доступ к нужным объектам (про DI как-нибудь поразмышляю отдельно), так и какую-нибудь замысловатую логику получения этих объектов. На этом уровне контракт компонентом не является, но. Во-первых, является на другом, понятийном уровне, задача такого компонента - скрывать от пользователя реализацию получения зависимостей. Во-вторых, компонентом однозначно является реализация этого контракта.</li>
  <li>Menu является с одной стороны вариацией DTO’шки, с чуть более закрытым контрактом чем у ClientAsk например, а с другой стороны контрактом, который скрывает логику получения настроек (а она может быть весьма замысловатой). Как и BaristaDependencies, Menu является компонентом на понятийном уровне (если бы мы рисовали схемку, то Menu был бы квадратиком над стрелочкой), и реализация этого контракта также будет компонентом.</li>
</ul>

<h2 id="модуль-как-компонент">Модуль как компонент</h2>

<p>Как я уже писал выше, компоненты фрактальны, а поэтому применять мы их можем не только к классам, но и к модулям. Таким образом у нас может быть модуль (давайте например думать в SPM-модулях для iOS/Swift) Баристы BaristaModule, который имеет Package.swift и в этом модуле лежит собственно исходный код по тому, как готовить кофе. Однако, реализовывать например, подачу воды или определение сортов кофе внутри этого модуля было бы неправильно, потому что подача воды и сорта кофе - это вещи, которыми пользуется не только бариста.</p>

<p>Таким образом мы могли бы определить еще модули, которые мы могли бы рассмотреть с позиции, что модуль BaristaModule - это компонент</p>

<ul>
  <li>Входные данные: нам нужен способ получать заказы клиентов, поэтому входными данными может быть модуль заказов (AskModule), в котором определяются способы сделать заказ и формализуются для передачи баристе</li>
  <li>Выходные данные: нам нужен способ передать чашку клиенту, и здесь может быть модуль, который непосредственно доставляет чашку, например OfficientModule. К слову на вход и выход может работать один и тот же модуль официанта.</li>
  <li>Зависимости: как уже писал выше - это все что необходимо для баристы для работы, поэтому сюда все модули, которые предоставляют функционал баристе (WaterTap, MilkProvider, CoffeeMachine Shop, …).</li>
  <li>Конфигурация: тут модуль управления, например дирекция кофе-буфетов.</li>
</ul>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2025/02/18/on-small-and-big-entities/">
        О сущностях больших и маленьких
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">18.02.2025</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#architecture" title="Pages tagged architecture" rel="tag" class="text-success">architecture</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#api" title="Pages tagged api" rel="tag" class="text-success">api</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#patterns" title="Pages tagged patterns" rel="tag" class="text-success">patterns</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#SOLID" title="Pages tagged SOLID" rel="tag" class="text-success">SOLID</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#ISP" title="Pages tagged ISP" rel="tag" class="text-success">ISP</a>
        </div>
        
      
    </p>

    <p>Сегодня поговорим о том, почему сущности вырастают. Вроде бы маленькие и понятные, через какое-то время они становятся большими и непонятными. Напоминает ситуацию, как будто вы приручили маленького котенка, а он потом вырос в саблезубого тигра. Почему так происходит и что делать? Постараюсь на простых примерах поразмышлять над этим.</p>

<h2 id="почему">Почему?</h2>

<p>Но начнем чуть издалека, рассмотрим такой пример. Нам надо включать лампочку. Оставим за скобками вечный вопрос сколько программистов для этого надо, и просто напишем код.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Lamp</span> <span class="p">{</span>
    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Вроде бы все отлично и все понятно (я намеренно опустил логику переключения, она тут вторична). Эта лампочка уходит в релиз и все работает, все довольны.</p>

<p>Но это не конец истории, через, скажем, месяц, приходит продакт и говорит, а теперь нам нужны диммируемые лампочки (это такие у которых яркость можно измерять, очень полезно). И вроде бы отлично, диммируемые лампочки - это хороший продукт. Мы засучиваем рукава и смело в бой. Модифицируем наш класс</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Lamp</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span>

    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="kt">Double</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">,</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isDimmable</span> <span class="o">=</span> <span class="n">isDimmable</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="n">isOn</span>
        <span class="k">self</span><span class="o">.</span><span class="n">dimValue</span> <span class="o">=</span> <span class="n">dimValue</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">dim</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">switchOn</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">dimValue</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1">// do the actual dim</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>и такой код даже будет работать. И вы даже быстро его напишите, и даже релиз случится. Но как мы видим, уже тут есть проблемы:</p>

<ol>
  <li>комбинаторика состояний isOn и dimValue. Я добавил некоторую проверку в функции dim(value:) но легко мог ее забыть. И тогда лампочка начала бы вести себя странно.</li>
  <li>любая простая лампочка начинает знать про dimValue даже если она не dimmable.</li>
</ol>

<p>прежде чем это все начинать фиксить, давайте еще усложним проблему. Продакты добавляют линейку устройств реле. Реле позволяет управлять не только светом, а например, чайником. Или светом но в выключателе. Или любым другим устройством которое можно включить в розетку. Отлично! Давайте чуть перепишем наш класс.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SomethingSwitchable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="k">let</span> <span class="nv">isRelay</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="k">let</span> <span class="nv">switchCallback</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>

    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="kt">Double</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">,</span> <span class="nv">isRelay</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">,</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nv">switchCallback</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isDimmable</span> <span class="o">=</span> <span class="n">isDimmable</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isRelay</span> <span class="o">=</span> <span class="n">isRelay</span>
        <span class="k">self</span><span class="o">.</span><span class="n">switchCallback</span> <span class="o">=</span> <span class="n">switchCallback</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isOn</span> <span class="o">=</span> <span class="n">isOn</span>
        <span class="k">self</span><span class="o">.</span><span class="n">dimValue</span> <span class="o">=</span> <span class="n">dimValue</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="c1">// do the actual switch</span>
        <span class="nf">switchCallback</span><span class="p">?(</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="c1">// do the actual switch</span>
        <span class="nf">switchCallback</span><span class="p">?(</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">dim</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">switchOn</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">dimValue</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1">// do the actual dim</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Lamp</span><span class="p">:</span> <span class="kt">SomethingSwitchable</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">,</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">isDimmable</span><span class="p">:</span> <span class="n">isDimmable</span><span class="p">,</span> <span class="nv">isRelay</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">isOn</span><span class="p">:</span> <span class="n">isOn</span><span class="p">,</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span> <span class="n">isOn</span> <span class="k">in</span>
            <span class="k">switch</span> <span class="n">isOn</span> <span class="p">{</span>
            <span class="k">case</span> <span class="nv">false</span><span class="p">:</span> <span class="c1">// do the actual switch off</span>
            <span class="k">case</span> <span class="nv">true</span><span class="p">:</span> <span class="c1">// do the actual swift on</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Relay</span><span class="p">:</span> <span class="kt">SomethingSwitchable</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">(</span><span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">switchCallback</span><span class="p">:</span> <span class="p">((</span><span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">isDimmable</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="nv">isRelay</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nv">isOn</span><span class="p">:</span> <span class="n">isOn</span><span class="p">,</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nv">switchCallback</span><span class="p">:</span> <span class="n">switchCallback</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Я даже показал, как можно вынести общую логику в “базовый класс”. Но по приведенному коду видно что мы пошли не туда. И наша маленькая приятная лампочка превратилась в страшное нечто.</p>

<h2 id="как-поправить">Как поправить?</h2>

<p>Для начала давайте разберем мелкие правки которые можно было сделать, чтобы чуть спасти ситуацию. Эти техники могут быть полезны в целом взять на вооружение.</p>

<p>Я упоминал комбинаторику состояний isOn и dimValue. Пока опустим то, что лампочка и диммируемая лампочка могут быть разными сущностями, просто попробуем исправить ситуацию.</p>

<p>Для этого, обозначим, что isOn и dimValue не являются полностью независимыми, в данном примере dimValue имеет смысл только тогда, когда isOn = true. И, как гласит принцип “явное лучше неявного”, сделаем это явно и перепишем код так:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Lamp</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">LampState</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">off</span>
        <span class="k">case</span> <span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span>

    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">LampState</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">LampState</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isDimmable</span> <span class="o">=</span> <span class="n">isDimmable</span>
        <span class="k">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="n">off</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">dim</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1">// do the actual dim</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>За счет явного введение LampState мы отразили любому читающему наш код, как работает состояние нашей лампочки. И даже код в dim(value:) стал более понятным - мы явно включим лампочку и включим ее в нужное состояние сразу (она не будем промаргивать через состояние 1.0).</p>

<p>Также можно явно заметить, что тип Double по области значений явно шире, чем нам надо. Явно диммирование управляется через диапазон 0-1. И это тоже можно явно отразить, опять же, явное лучше неявного.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">DimValue</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">minimum</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">maximum</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="k">Self</span><span class="o">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nv">min</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="n">minimum</span><span class="p">,</span> <span class="nv">max</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="n">maximum</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">clamp</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">min</span><span class="p">:</span> <span class="kt">Double</span><span class="p">,</span> <span class="nv">max</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Double</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">Swift</span><span class="o">.</span><span class="nf">max</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="kt">Swift</span><span class="o">.</span><span class="nf">min</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">max</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">setValue</span><span class="p">(</span><span class="n">_</span> <span class="nv">newValue</span><span class="p">:</span> <span class="kt">Double</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="k">Self</span><span class="o">.</span><span class="nf">clamp</span><span class="p">(</span><span class="n">newValue</span><span class="p">,</span> <span class="nv">min</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="n">minimum</span><span class="p">,</span> <span class="nv">max</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="n">maximum</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="k">let</span> <span class="nv">max</span> <span class="o">=</span> <span class="kt">DimValue</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="n">maximum</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Lamp</span> <span class="p">{</span>
    <span class="kd">enum</span> <span class="kt">LampState</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">off</span>
        <span class="k">case</span> <span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">DimValue</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span>

    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">LampState</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">isDimmable</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">LampState</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">isDimmable</span> <span class="o">=</span> <span class="n">isDimmable</span>
        <span class="k">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="n">off</span>
        <span class="c1">// do the actual switch</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">dim</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">DimValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1">// do the actual dim</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Таким образом мы увидим несоответствие кода сразу же, да еще и компилятором проверим.</p>

<p>Меня можно укорить в том, что я на самом деле увеличил объем кода по сравнению с моей же реализацией диммируемой лампочки. Да, кода стало чуть больше, но он стал более явно выражать то, что он делает, без предположений существующих только в головах.</p>

<p>Теперь давайте рассмотрим более фундаментальную проблему - у нас все лампочки диммируемые. Даже те, которые нет. И на самом деле поле isDimmable не сильно помогает решить проблему, потому что как вы можете заметить, оно устанавливается в конструкторе, но нигде не используется - про него забыли.</p>

<p>И попутно непонятно, а как теперь быть лампочкам недиммируемым? Игнорировать значение диммера?</p>

<p>Давайте начнем приводить код в чувство, попутно учитывая будущее когда у нас появится реле.</p>

<p>Формально - у нас есть три сущности:</p>

<ul>
  <li>Что-то что может включаться</li>
  <li>Что-то что может диммироваться</li>
  <li>Что-то что может включать других (ака реле)</li>
</ul>

<p>На самом деле наш код базовой реализации класса SomethingSwitchable дает еще и четвертый вариант, что-то вроде “диммируемого реле”, которое на самом деле может быть регулятором скорости/яркости.</p>

<p>Попутно вспомним <a href="https://ru.wikipedia.org/wiki/Принцип_разделения_интерфейса">Interface Segregation Principle</a> и заведем такие сущности.</p>

<p>Для начала что-то, что может переключаться</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Switchable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span>
    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Это может быть лампочка, может быть реле. Далее, что-то что можно диммировать</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Dimmable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="kt">DimValue</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">dim</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">DimValue</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>И наконец, что-то, что может управлять другими</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">Controling</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">setSwitchCallback</span><span class="p">(</span><span class="n">_</span> <span class="nv">switchCallback</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="n">_</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Теперь у нас есть базовые кубики, из которых мы можем строить что-то более сложное.</p>

<p>Простую лампочку сделаем так</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">YablochkovLamp</span><span class="p">:</span> <span class="kt">Switchable</span> <span class="p">{</span>
    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="c1">// do the on logic</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="c1">// do the off logic</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Заметьте, она может включаться/выключаться, ее состояние простое. Оно не искажается состоянием диммируемой лампочки и может использовать простое булево значение (вопросы thread-safety пока опустим).</p>

<p>Диммируемая лампочка будет такой:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">DimmableLamp</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kd">enum</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">off</span>
        <span class="k">case</span> <span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">DimValue</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span> <span class="o">=</span> <span class="o">.</span><span class="n">off</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">DimmableLamp</span><span class="p">:</span> <span class="kt">Switchable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">state</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">off</span><span class="p">:</span> <span class="k">return</span> <span class="kc">false</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">on</span><span class="p">:</span> <span class="k">return</span> <span class="kc">true</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="c1">// do the logic</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="n">off</span>
        <span class="c1">// do the logic</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">DimmableLamp</span><span class="p">:</span> <span class="kt">Dimmable</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">dimValue</span><span class="p">:</span> <span class="kt">DimValue</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">state</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">.</span><span class="nv">off</span><span class="p">:</span> <span class="k">return</span> <span class="o">.</span><span class="n">min</span>
        <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">on</span><span class="p">(</span><span class="n">value</span><span class="p">):</span> <span class="k">return</span> <span class="n">value</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">dim</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">DimValue</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">on</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1">// do the logic</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Тут отметим, что на уровне типов можно явно отметить, что эта лампочка диммируемая, теперь сложно об этом забыть. Кроме того, я показал, что с помощью extension’ов можно расширить логику после создания типа (ретроактивно). И в довесок спрятал от внешнего наблюдателя внутреннее состояние лампочки.</p>

<p>Ну и теперь реле:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Relay</span> <span class="p">{</span>
    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="o">=</span> <span class="kc">false</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">switchCallback</span><span class="p">:</span> <span class="p">((</span><span class="n">_</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Relay</span><span class="p">:</span> <span class="kt">Switchable</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="nf">switchCallback</span><span class="p">?(</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">isOn</span> <span class="o">=</span> <span class="kc">false</span>
        <span class="nf">switchCallback</span><span class="p">?(</span><span class="n">isOn</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">Relay</span><span class="p">:</span> <span class="kt">Controling</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">setSwitchCallback</span><span class="p">(</span><span class="n">_</span> <span class="nv">switchCallback</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">switchCallback</span> <span class="o">=</span> <span class="n">switchCallback</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Как видим состояние реле проще состояние диммируемой лампочки (не надо явно учитывать сайд эффект и понятно), но при этом функциональность реле реализована так, как надо.</p>

<p>Такая детализация позволяет:</p>

<ul>
  <li>Строить сущности из кубиков (я не упоминул еще о дефолтных реализация в протоколах, что тоже улучшает ситуацию)</li>
  <li>Уменьшать комбинаторный взрыв за счет разделения и в целом упрощать реализацию сущностей</li>
  <li>Заменять конкретные классы в процессе развития кода на другие, удовлетворяющие контракту.</li>
</ul>

<p>Про третий пункт отдельно. Например, лампочка у нас “уехала” на другой хост в ip сети, и чтобы скрыть от управляющего кода этот факт и не делать его сложнее чем надо, мы можем изобрести такую связку проксей:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">SwitchableProxyClient</span><span class="p">:</span> <span class="kt">Switchable</span> <span class="p">{</span>
    <span class="c1">// private let network: NetworkClient</span>

    <span class="k">var</span> <span class="nv">isOn</span><span class="p">:</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="c1">// network.proxyIsOn</span>
        <span class="k">return</span> <span class="kc">false</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOn</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// network.proxySwitchOn()</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">switchOff</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// network.proxySwitchOff()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">SwitchableProxyServer</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">switchable</span><span class="p">:</span> <span class="kt">Switchable</span>
    <span class="c1">// private let networkServer: NetworkServer</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">switchable</span><span class="p">:</span> <span class="kt">Switchable</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">switchable</span> <span class="o">=</span> <span class="n">switchable</span>
        <span class="c1">// networkServer.switchOn = {</span>
        <span class="c1">//   switchable.switchOn()</span>
        <span class="c1">// }</span>
        <span class="c1">// networkServer.switchOff = {</span>
        <span class="c1">//   switchable.switchOff()</span>
        <span class="c1">// }</span>
        <span class="c1">// networkServer.isOn = {</span>
        <span class="c1">//   switchable.isOn</span>
        <span class="c1">// }</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>и благодаря им, управляющий код не будет знать, что лампочка “уехала”, а в проксе можно реализовать гарантии надежности для всех, кто может быть Switchable.</p>

<h2 id="а-мораль">А мораль?</h2>

<p>А мораль в том, что, когда вы пишите или что еще более важно модифицируете какую-то сущность, хорошо бы подумать о том, как ваша модификация сказывается на том, чем сущность является. Не превращаете ли вы ее в франкенштейна и может быть ее стоит подробить на концепции и эти концепции использовать.</p>

<p>В конце концов, то как вы обозначили контракт вашей сущности влияет на то, как ее используют. И как понимают в целом, что это.</p>


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2024/04/08/notes-on-di/">
        Заметки о Dependency Injection
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">08.04.2024</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#swift" title="Pages tagged swift" rel="tag" class="text-success">swift</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#ios" title="Pages tagged ios" rel="tag" class="text-success">ios</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#kotlin" title="Pages tagged kotlin" rel="tag" class="text-success">kotlin</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#android" title="Pages tagged android" rel="tag" class="text-success">android</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#di" title="Pages tagged di" rel="tag" class="text-success">di</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#dependency+injection" title="Pages tagged dependency injection" rel="tag" class="text-success">dependency injection</a>
        </div>
        
      
    </p>

    <p>Тема внедрение зависимостей одна из краеугольных в целом при любой разработке. И, благодаря этому, одна из наиболее дискуссионных, порой доходящаяя до уровня “священных войн” между апологетами разных подходов. В этой статье постараюсь изложить свое видение подходов к решению проблем.</p>

<h2 id="преамбула">Преамбула</h2>

<p>Для того, чтобы не превращать эту статью в рассказ “от сотворения мира”, очень рекомендую посмотреть <a href="https://www.youtube.com/live/GA1NY-RKkhs?si=HBUhtDkeJZYBgfhX&amp;t=4399">это видео</a> (с указанного таймкода, лекция там в целом про архитектуру, но нас в рамках этой статьи будут интересовать выкладки про DI).</p>

<h2 id="постановка-проблемы">Постановка проблемы</h2>

<h3 id="базовая-задача">Базовая задача</h3>

<p>Итак, мы стараемся придумать решение следующей проблемы</p>

<ul id="task" class="tab" data-tab="4e7cbb83-b6ed-446f-907c-d97935677b99" data-name="task">
  
      <li class="active" id="task-swift">
          <a href="#">Swift </a>
      </li>
  
      <li id="task-kotlin">
          <a href="#">Kotlin </a>
      </li>
  
</ul>
<ul class="tab-content" id="4e7cbb83-b6ed-446f-907c-d97935677b99" data-name="task">
  
      <li class="active">
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">protocol</span> <span class="kt">SomeBookService</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">class</span> <span class="kt">BookProcessor</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">service</span><span class="p">:</span> <span class="kt">SomeBookService</span> <span class="o">=</span> <span class="kt">SomeBookServiceImpl</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

</li>
  
      <li>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">SomeBookService</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

<span class="kd">class</span> <span class="nc">BookProcessor</span><span class="p">(</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">service</span><span class="p">:</span> <span class="nc">SomeBookService</span> <span class="p">=</span> <span class="nc">SomeBookServiceImpl</span><span class="p">()</span>
<span class="p">)</span>
</code></pre></div></div>

</li>
  
</ul>

<p>Что мы хотим от хорошего решения?</p>

<ul>
  <li><strong>Через протокол/интерфейс.</strong> Использующий зависимость класс не должен знать о конкретной реализации и должен иметь работать с любой реализацией правильно реализующей контракт (объявленный в протоколе/интерфейсе).</li>
  <li><strong>Узкий контракт.</strong> Реализация, которую мы получаем в виде зависимости должена иметь минимально необходимый контракт. Наша сущность не должна видеть лишнего</li>
  <li><strong>Необходимость и достаточность.</strong> Поставляемые зафисимости поставляются в необходимом и достаточном объеме, не требуется каких-то специальных приседаний для того, чтобы получить что-то еще (это как правило относится к запрету использовать внутри синглтоны).</li>
  <li><strong>Реализация DI для логического кода “невидима”.</strong> Мы не должны видеть фрагменты порождающего кода где-либо (кроме некоторых исключений).</li>
</ul>

<h3 id="платформенные-особенности">Платформенные особенности</h3>

<p>Мы рассматриваем мобильные платформы (в целом можно рассматривать и серверные, но там как правило все проще в этом плане).</p>

<h4 id="ios">iOS</h4>

<p>Как правило, все сущности iOS позволяют нормально реализовать constructor injection паттерн без необходимости построения специальных решений. Иногда требуются специальные действия для создания циклических зависимостей, но они легко решаются способами, описанными ниже.</p>

<p>Единственный объект, который система создает сама - это UIApplication (и applicationDidFinishLaunchingWithOptions) или SwiftUI объект обозначенный как @main. Но эти объекты будем считать точкой входа и растить графы от них.</p>

<h4 id="android">Android</h4>

<p>У Android также как и в iOS есть главный объект создаваемый системой - Application, но есть и важное отличие - в Android есть объекты, которые фреймворком могут быть убиты и пересозданы через тривиальный конструктор, такие как Activity, Fragment, View и тд. И есть общепринятая практика использовать для иньекции зависимостей в такие объекты через паттерн Service Locator. Service Locator считаем антипаттерном (как минимум он противоречит принципам хорошего решения, упомянутым выше).</p>

<p>Поэтому для решение проблемы спец сущностей (которые могут быть пересозданы), в Android надо предусмотреть дополнительные средства.</p>

<h3 id="o-service-locatorе">O Service Locator’е</h3>

<p><a href="https://ru.wikipedia.org/wiki/Локатор_служб">Service Locator</a> это такой паттерн проектирования, который, упрощенно говоря, предоставляет единую точку, через которую можно запросить разные зависимости. В рамках создания библиотек для DI он обычно соседствует с паттерном <a href="https://ru.wikipedia.org/wiki/Одиночка_(шаблон_проектирования)">Singleton</a> предоставляя публично известный разделяемый объект, из которого можно запросить практически все что угодно.</p>

<p>Я считаю его антипаттерном в применении к задачам DI (у него есть другая применимость, которая норм).</p>

<p>Но чтобы не быть голословным, давайте рассмотрим поставленные требования к хорошему решению:</p>

<ul>
  <li><strong>Через протокол/интерфейс</strong> - эту задачу в целом можно решить, отдавая из публичного singleton’а сервис локатора интерфейсы</li>
  <li><strong>Узкий контракт</strong> - так как точка эта общеизвестная, то надо отдавать зависимость целиком, что нарушает принцип сужения контракта. Можно из публичного singleton’а отдавать одну реализацию под набором интерфейсов, но тогда у нас будет очень сложно выглядеть общий контракт такого объекта, сложно будет что-то в нем найти.</li>
  <li><strong>Необходимость и достаточность</strong> - мы показываем всевозмоюжные интерфейсы или даже реализации, что любой клиент может видеть все приложение, что явно нарушает это требование</li>
  <li><strong>“Невидимость”</strong> - требование явно нарушается, так как из любой точки приложения можно публичный singleton локатора</li>
</ul>

<p>Таким образом Service Locator использовать не стоит, поэтому будем строить решение на базе концепции контейнера.</p>

<h3 id="о-библиотечных-решениях">О библиотечных решениях</h3>

<p>В мире написано огромное количество библиотек, заявляющих что так или иначе решают проблему внедрения зависимостей. Однако большая часть из них основана на паттерне Service Locator. Справедливости ради стоит сказать, что наиболее популярная библиотека Dagger 2 для Android пытается использовать концепцию контейнера, и в Sevice Locator его чаще всего превращают при использовании.</p>

<h2 id="идея-решения-проблемы">Идея решения проблемы</h2>

<p>Как уже было сказано выше - будем использовать концепцию контейнера.</p>

<p>Контейнер - это такая сущность, которыя</p>

<ul>
  <li>Создает нужные объекты и управляет их временем жизни</li>
  <li>Настраивает связи между ними</li>
  <li>Невидима для самих объектов</li>
</ul>

<p>Каждая конкретная логическая сущность (кроме самих контейнеров) заявляет необходимость зависимостей (через constructor или property injection) и все. Никоим образом логическая сущность не получает доступа не к типу контейнера, ни к его инстансу (кроме как через Factory интерфейсы там где нужна prototype зависимость).</p>

<p>Отступление про нейминг. Однажды я увидел, как в коде контейнеры называют графами (Graph) и мне эта идея так понравилась, что далее буду называть типы контейнеров графами, можно в рамках этой заметки считать эти термины эквивалентными для задач DI.</p>

<p>Таким образом простейший контейнер может выглядеть так</p>

<ul id="container" class="tab" data-tab="3dc8cee2-e14f-4e36-801d-755883586de6" data-name="container">
  
      <li class="active" id="container-swift">
          <a href="#">Swift </a>
      </li>
  
      <li id="container-kotlin">
          <a href="#">Kotlin </a>
      </li>
  
</ul>
<ul class="tab-content" id="3dc8cee2-e14f-4e36-801d-755883586de6" data-name="container">
  
      <li class="active">
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">SomeGraph</span> <span class="p">{</span>

    <span class="c1">// 'singleton' entities</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">dep1</span><span class="p">:</span> <span class="kt">Dep1</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">dep2</span><span class="p">:</span> <span class="kt">Dep2</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">dep3</span><span class="p">:</span> <span class="kt">Dep3</span>

    <span class="c1">// other graphs</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">subGraph</span><span class="p">:</span> <span class="kt">SomeSubGraph</span>

    <span class="nf">init</span><span class="p">(</span>
        <span class="nv">someGraphDependencies</span><span class="p">:</span> <span class="kt">SomeGraphDependencies</span><span class="p">,</span>
        <span class="nv">someSpecificDependency</span><span class="p">:</span> <span class="kt">SomeSpecificDependency</span><span class="p">,</span>
        <span class="nv">configuration</span><span class="p">:</span> <span class="kt">SomeGraphConfiguration</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">dep1</span> <span class="o">=</span> <span class="kt">Dep1</span><span class="p">(</span>
            <span class="cm">/* ... */</span><span class="p">,</span>
            <span class="nv">makeSome</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="nf">makeSomePrototypeDep</span><span class="p">(</span><span class="nv">val</span><span class="p">:</span> <span class="n">configuration</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">dep2</span> <span class="o">=</span> <span class="kt">Dep2</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">,</span> <span class="nv">useVal</span><span class="p">:</span> <span class="n">configuration</span><span class="o">.</span><span class="n">useVal</span><span class="p">)</span>
        <span class="k">self</span><span class="o">.</span><span class="n">dep3</span> <span class="o">=</span> <span class="kt">Dep3</span><span class="p">(</span><span class="nv">dep1</span><span class="p">:</span> <span class="kt">Dep1</span><span class="p">,</span> <span class="nv">dep2</span><span class="p">:</span> <span class="kt">Dep2</span><span class="p">)</span>
        <span class="c1">// ...</span>
        <span class="k">self</span><span class="o">.</span><span class="n">subGraph</span> <span class="o">=</span> <span class="kt">SomeSubGraph</span><span class="p">(</span>
            <span class="cm">/* ... */</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">deinit</span> <span class="p">{</span>
        <span class="c1">// тут некоторая логика очистки сущностей, которые того требуют</span>
    <span class="p">}</span>

    <span class="c1">// 'prototype' entities</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">makeSomePrototypeDep</span><span class="p">(</span><span class="nv">val</span><span class="p">:</span> <span class="kt">Val1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Dep4</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">return</span> <span class="kt">Dep4</span><span class="p">(</span>
            <span class="nv">val</span><span class="p">:</span> <span class="n">val</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

</li>
  
      <li>
<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SomeGraph</span><span class="p">(</span>
    <span class="n">someGraphDependencies</span><span class="p">:</span> <span class="nc">SomeGraphDependencies</span><span class="p">,</span>
    <span class="n">someSpecificDependency</span><span class="p">:</span> <span class="nc">SomeSpecificDependency</span><span class="p">,</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">configuration</span><span class="p">:</span> <span class="nc">SomeGraphConfiguration</span><span class="p">,</span>
    <span class="o">..</span><span class="p">.</span>
<span class="p">)</span> <span class="p">{</span>

    <span class="c1">// 'singleton' entities</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">dep1</span><span class="p">:</span> <span class="nc">Dep1</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">dep2</span><span class="p">:</span> <span class="nc">Dep2</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">dep3</span><span class="p">:</span> <span class="nc">Dep3</span>

    <span class="c1">// other graphs</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">subGraph</span><span class="p">:</span> <span class="nc">SomeSubGraph</span>

    <span class="nf">init</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">dep1</span> <span class="p">=</span> <span class="nc">Dep1</span><span class="p">(</span>
            <span class="cm">/* ... */</span><span class="p">,</span>
            <span class="n">makeSome</span> <span class="p">=</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">makeSomePrototypeDep</span><span class="p">(</span><span class="kd">val</span> <span class="err">=</span> <span class="py">configuration</span><span class="p">.</span><span class="k">val</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="n">dep2</span> <span class="p">=</span> <span class="nc">Dep2</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">,</span> <span class="n">useVal</span> <span class="p">=</span> <span class="n">configuration</span><span class="p">.</span><span class="n">useVal</span><span class="p">)</span>
        <span class="k">this</span><span class="p">.</span><span class="n">dep3</span> <span class="p">=</span> <span class="nc">Dep3</span><span class="p">(</span><span class="n">dep1</span> <span class="p">=</span> <span class="nc">Dep1</span><span class="p">,</span> <span class="n">dep2</span> <span class="p">=</span> <span class="nc">Dep2</span><span class="p">)</span>
        <span class="c1">// ...</span>
        <span class="k">this</span><span class="p">.</span><span class="n">subGraph</span> <span class="p">=</span> <span class="nc">SomeSubGraph</span><span class="p">(</span>
            <span class="cm">/* ... */</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fun</span> <span class="nf">cleanup</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// в Java/Kotlin нет полноценных деструкторов, поэтому cleanup методы</span>
        <span class="c1">// необходимо будет вызывать руками</span>
        <span class="c1">// тут некоторая логика очистки сущностей, которые того требуют</span>
    <span class="p">}</span>

    <span class="c1">// 'prototype' entities</span>
    <span class="k">private</span> <span class="k">fun</span> <span class="nf">makeSomePrototypeDep</span><span class="p">(</span><span class="k">val</span><span class="p">:</span> <span class="nc">Val1</span><span class="p">):</span> <span class="nc">Dep4</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">return</span> <span class="nc">Dep4</span><span class="p">(</span>
            <span class="kd">val</span> <span class="err">=</span> <span class="py">val</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

</li>
  
</ul>

<p>И все - собирайте нужную конструкцию из иерархических графов. Когда какой-то набор сущностей станет ненужным - зануляете граф и все очищается (в Android не забываем звать cleanup).</p>

<p>PROFIT? не совсем, есть тонкости</p>

<h3 id="ios-1">iOS</h3>

<p>В iOS как правило все проходит без проблем. Мы создаем корневой граф-контейнер в applicationWill/DidLaunchingWithOptions и передаем его целиком или частями в дальнейшие сущности, или создаем его в корневом объекте помеченном @main и также передаем целиком или частями дальше. Главное не забывать о сужении интерфейсов и принципе достаточной необходимости.</p>

<h3 id="android-1">Android</h3>

<p>Для бизнесовых сущностей достаточно также в рамках класса Application создать корневой граф и действовать аналогично iOS, но, как я уже выше упоминал, есть проблемы с андроидными сущностями. Поэтому для них нужно специальное решение.</p>

<p>Заведем пару контрактов</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// любая сущность, в которую наш DI сможет что-то инжектить</span>
<span class="kd">interface</span> <span class="nc">Injectable</span>

<span class="c1">// контракт сущности контейнера, который сможет что-то куда-то инжектить</span>
<span class="kd">interface</span> <span class="nc">Injector</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">inject</span><span class="p">(</span><span class="n">into</span><span class="p">:</span> <span class="nc">Injectable</span><span class="p">)</span> <span class="c1">// можно опционально return Result</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Чуть выше в разделе про Service Locator я уже говорил, что основная проблема в нем в том, что</p>

<ul>
  <li>его shared instance известен публично, и может быть использован скрыто. С этим увы ничего не поделать, андроидные компоненты устроены так, что нам придется пойти на открытие какого-то shared instance. Для activity/fragment есть лазейка, о ней чуть позже, но в общем итоге не поделать ничего.</li>
  <li>из него можно достать что угодно, эту проблему будем решать.</li>
</ul>

<p>Также важно, что для Android компонентов инъекция будет асинхронной относительно вызова конструктора объектов, поэтому полноценную compile time проверку мы сделать не сможем. Ограничимся сокрытием лишней информации.</p>

<p>Теперь нам нужно предусмотреть сущность, которую мы будем видеть через shared instance, но не моч из нее ничего достать</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SomeGraph</span> <span class="k">private</span> <span class="k">constructor</span><span class="p">(</span>
    <span class="k">private</span> <span class="kd">val</span> <span class="py">dependency</span><span class="p">:</span> <span class="nc">SomeDependnecy</span><span class="p">,</span>
    <span class="c1">// other deps</span>
<span class="p">):</span> <span class="nc">Injector</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">inject</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nc">Injectable</span><span class="p">)</span> <span class="p">=</span> <span class="k">when</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">is</span> <span class="nc">SomeKnownFragment</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="n">target</span><span class="p">.</span><span class="n">dependency</span> <span class="p">=</span> <span class="n">dependency</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{</span>
            <span class="c1">// report error in some kind</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">companion</span> <span class="k">object</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="py">sharedInstance</span><span class="p">:</span> <span class="nc">SomeGraph</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
            <span class="k">private</span> <span class="k">set</span>

        <span class="k">fun</span> <span class="nf">setup</span><span class="p">(</span>
            <span class="n">dependency</span><span class="p">:</span> <span class="nc">SomeDependency</span>
        <span class="p">)</span> <span class="p">{</span>
            <span class="nf">synchronized</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">sharedInstance</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span>
                <span class="p">}</span>
                <span class="n">sharedInstance</span> <span class="p">=</span> <span class="nc">SomeGraph</span><span class="p">(</span>
                    <span class="n">dependency</span> <span class="p">=</span> <span class="n">dependency</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>И теперь в условном фрагменте мы можем написать так</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SomeKnownFragment</span><span class="p">:</span> <span class="nc">Fragment</span><span class="p">(),</span> <span class="nc">Injectable</span> <span class="p">{</span>

    <span class="k">lateinit</span> <span class="kd">var</span> <span class="py">dependency</span><span class="p">:</span> <span class="nc">Dependency</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onAttach</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="nc">Context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onAttach</span><span class="p">(</span><span class="n">context</span><span class="p">)</span>
        <span class="nc">SomeGraph</span><span class="p">.</span><span class="n">sharedInstance</span><span class="o">?.</span><span class="nf">inject</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Как я уже сказал, есть некоторая проблема в том, что связывание будет проверено только в runtime, а правильнее было бы сделать в compile time, но архитектура компонентов Android’а тут этому препятствует.</p>

<p>К слову такой подход хорошо подходит для библиотек, этот SomeGraph может быть объектов библиотеки, которую надо проинициализировать и потом сама библиотека будет ее использовать. Для Activity/Fragment и тд можем сделать лучше, для этого нам потребуется еще немножко сахара (покажу на примере Activity, для фрагментов можно сделать аналогично)</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nc">Activity</span><span class="p">.</span><span class="nf">inject</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">thisAsInjectable</span> <span class="p">=</span> <span class="k">this</span> <span class="k">as</span><span class="p">?</span> <span class="nc">Injectable</span> <span class="o">?:</span> <span class="k">throw</span> <span class="nc">InjectException</span><span class="p">(</span><span class="s">"activity not injectable"</span><span class="p">)</span>
    <span class="kd">val</span> <span class="py">application</span> <span class="p">=</span> <span class="n">application</span> <span class="o">?:</span> <span class="k">throw</span> <span class="nc">InjectException</span><span class="p">(</span><span class="s">"application isn't set to activity"</span><span class="p">)</span>
    <span class="kd">val</span> <span class="py">injector</span> <span class="p">=</span> <span class="n">application</span> <span class="k">as</span><span class="p">?</span> <span class="nc">Injector</span> <span class="o">?:</span> <span class="k">throw</span> <span class="nc">InjectException</span><span class="p">(</span><span class="s">"application is not an injector"</span><span class="p">)</span>
    <span class="n">injector</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">thisAsInjectable</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>теперь надо класс приложения разметить соответствующим образом</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">YourApp</span><span class="p">:</span> <span class="nc">Application</span><span class="p">(),</span> <span class="nc">Injector</span> <span class="p">{</span>

    <span class="k">private</span> <span class="k">lateinit</span> <span class="kd">var</span> <span class="py">rootGraph</span><span class="p">:</span> <span class="nc">RootGraph</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">()</span>
        <span class="n">rootGraph</span> <span class="p">=</span> <span class="nc">RootGraph</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">inject</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nc">Injectable</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="k">this</span><span class="o">::</span><span class="n">graph</span><span class="p">.</span><span class="n">isInitialized</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">error</span><span class="p">(</span><span class="s">"Application isn't properly initialized yet"</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">graph</span><span class="p">.</span><span class="nf">inject</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>корневой граф будет выглядеть примерно так</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RootGraph</span><span class="p">(</span>
    <span class="n">applicationContext</span><span class="p">:</span> <span class="nc">Context</span>
<span class="p">):</span> <span class="nc">Injector</span> <span class="p">{</span>

    <span class="c1">// private val yourdeps = ...</span>

    <span class="nf">init</span> <span class="p">{</span>
        <span class="c1">// тут инициализация нужных компонентов</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">inject</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nc">Injectable</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">when</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">is</span> <span class="nc">MainActivity</span> <span class="p">-&gt;</span> <span class="p">{</span>
                <span class="n">target</span><span class="p">.</span><span class="n">depepdency</span> <span class="p">=</span> <span class="o">..</span><span class="p">.</span>
            <span class="p">}</span>
            <span class="c1">// можно делегировать что-то субграфам</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>И в самой активити будет просто</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="nc">Activity</span><span class="p">(),</span> <span class="nc">Injectable</span> <span class="p">{</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="nc">Bundle</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">.</span><span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>

        <span class="nf">inject</span><span class="p">()</span>

        <span class="c1">// остальная инициализация</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Никаких синглетонов и никакого раскрытия лишних зависимостей - PROFIT.</p>

<p>P.S. Если придумаете как решить эту проблему с аналогичными гарантиями да еще и в compile time буду благодарен</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/11/06/swift-dependency-injection/">
        Внедрение зависимостей (dependency injection) в Swift 5.1
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">06.11.2019</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#swift" title="Pages tagged swift" rel="tag" class="text-success">swift</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#ios" title="Pages tagged ios" rel="tag" class="text-success">ios</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#di" title="Pages tagged di" rel="tag" class="text-success">di</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#dependency+injection" title="Pages tagged dependency injection" rel="tag" class="text-success">dependency injection</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#property+wrappers" title="Pages tagged property wrappers" rel="tag" class="text-success">property wrappers</a>
        </div>
        
      
    </p>

    <p>Внедрение зависимостей очень горячая тема в любой области разработки, где мы пишем что-то более сложное чем Hello, World. Однако несмотря на казалось бы изученный вдоль и поперек вопрос, вариантов его решения вы можете на просторах интернета найти великое множество. И в каждом месте оно подается как единственно правильное. И как же выбрать? Предлагаю в этой статье немножко рассмотреть подходы, их плюсы и минусы, немножко поиграться со Swift’ом вообще и попробовать его новые фичи в виде @PropertyWrapper’s.</p>

<p>Итак, постановка задачи у нас будет такая - у нас есть два класса BooksRenderer, который просто каким-то образом рисует книжки, и BooksProvider, который ему их поставляет. На Swift это будет выглядеть примерно так:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">BooksRenderer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">provider</span><span class="p">:</span> <span class="kt">BooksProvider</span> <span class="o">=</span> <span class="o">...</span> <span class="cm">/* за это троеточие и будет вестись основная борьба */</span>

    <span class="kd">func</span> <span class="nf">draw</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">books</span> <span class="o">=</span> <span class="n">provider</span><span class="o">.</span><span class="n">books</span>
        <span class="cm">/* тут каким-то образом рисуются книги из массива books */</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">protocol</span> <span class="kt">BooksProvider</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">books</span><span class="p">:</span> <span class="p">[</span><span class="kt">Book</span><span class="p">]</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Будем также считать что есть некая реализация протокола BooksProvider, например такая наивная</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">NaiveBooksProvider</span><span class="p">:</span> <span class="kt">BooksProvider</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">books</span><span class="p">:</span> <span class="p">[</span><span class="kt">Book</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="kt">Book</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"Dune"</span><span class="p">,</span> <span class="nv">author</span><span class="p">:</span> <span class="s">"Frank Herbert"</span><span class="p">),</span>
            <span class="kt">Book</span><span class="p">(</span><span class="nv">title</span><span class="p">:</span> <span class="s">"Lord of the Rings"</span><span class="p">,</span> <span class="nv">author</span><span class="p">:</span> <span class="s">"John R.R. Tolkien"</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Теперь наша задача каким-то образом доставить экземпляр класса NaiveBooksProvider в BooksRenderer. Самый наивный подход такой, создать экземлляр класса прямо на месте:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">BooksRenderer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">provider</span><span class="p">:</span> <span class="kt">BooksProvider</span> <span class="o">=</span> <span class="kt">NaiveBooksProvider</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Несмотря на то, что этот подход, каким бы наивным он не был, много где применяется, у него есть очевидные недостатки:</p>

<ol>
  <li>Мы можем захотеть как-то менять конкретный класс реализации, а он тут “прибит гвоздями”</li>
  <li>Мы можем захотеть unit-протестировать класс BooksRenderer, и тогда вместо провайдера захотим вставить какой-нибудь мок
и т.д.</li>
</ol>

<p>Нам надо что-то лучше. И много где предлагают хорошо известный паттер ServiceLocator. Если его применить, то выглядеть это будет примерно так:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">ServiceLocator</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">booksProvider</span><span class="p">:</span> <span class="kt">BooksProvider</span> <span class="o">=</span> <span class="kt">NaiveBooksProvider</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">BooksRenderer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">provider</span><span class="p">:</span> <span class="kt">BooksProvider</span> <span class="o">=</span> <span class="kt">ServiceLocator</span><span class="o">.</span><span class="n">booksProvider</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Уже лучше, ответственность за выбор конкретного класса мы достали из BooksRenderer и наделили этой почетной обязанностью класс ServiceLocator. И мы даже можем сделать разные ServiceLocator’ы для основного приложения и для тестов, которые будут создавать разные BooksProvider’ы, однако:</p>

<ol>
  <li>Теперь 90% кода будет знать про класс ServiceLocator</li>
  <li>Класс ServiceLocator будет огромным (кто там что говорил про Massive View Controller?, у нас тут Massive Service Locator)</li>
</ol>

<p>Прежде чем пойти дальше, давайте сделаем некоторое лирическое отступление, разберемся в терминологии зависимостей. Вообще внедряемых зависимостей может быть два типа: прости хоспади singleton (но это не то что вы подумали) и prototype. “singleton” зависимости - это такие зависимости, которые сколько бы вы не внедряли в рамках одного конкретного модуля, это всегда будет один экземпляр. “prototype” же - даст на каждую точку внедрения новый экземпляр.</p>

<p>Поэтому если говорить про наш пример с ServiceLocator’ом, то например booksProvider - это singleton зависимость, а bookUpdateOperation - prototype:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">ServiceLocator</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="k">let</span> <span class="nv">booksProvider</span><span class="p">:</span> <span class="kt">BooksProvider</span> <span class="o">=</span> <span class="kt">NaiveBooksProvider</span><span class="p">()</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">bookUpdateOperation</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">Operation</span> <span class="o">&amp;</span> <span class="kt">BookUpdate</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">NaiveBookUpdateOperation</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Теперь давайте сделаем еще одно лирическое отступление, подчерпнутое мной когда я еще занимался “кровавым” enterprise и работал с <a href="http://spring.io">Srping Framework</a>. Хороший DI контейнер это такой контейнер, который не видно. Тут можно еще пофилософствовать и вспомнить <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjEo_P2mdblAhV8wsQBHaObD_EQFjACegQIDRAG&amp;url=https%3A%2F%2Fru.wikipedia.org%2Fwiki%2F%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D1%2580%25D0%25B5%25D1%2588%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B8%25D0%25B7%25D0%25BE%25D0%25B1%25D1%2580%25D0%25B5%25D1%2582%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D1%2581%25D0%25BA%25D0%25B8%25D1%2585_%25D0%25B7%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587&amp;usg=AOvVaw0VcQvVNp9cBvIu5iqYojs9">ТРИЗ</a> с ее идеальным конечным результатом, который на наш DI’ный контекст перефразируется так: “хороший DI контейнер - это такой, которого нет, а зависимости внедряются”.</p>

<p>Таким образом, можно сделать такой DI на базе initializer injection (оно лучше property injection, потому что компилятор в этом случае не даст вам озорничать, а с property injection легко забыть что-нибудь присвоить и грохнуться в рантайме):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">AppContainer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">booksProvider</span><span class="p">:</span> <span class="kt">BooksProvider</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">with</span> <span class="nv">appDelegate</span><span class="p">:</span> <span class="kt">AppDelegate</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">booksProvider</span> <span class="o">=</span> <span class="kt">NaiveBooksProvider</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
        <span class="n">appDelegate</span><span class="o">.</span><span class="n">booksRenderer</span> <span class="o">=</span> <span class="kt">BooksRenderer</span><span class="p">(</span><span class="nv">provider</span><span class="p">:</span> <span class="n">booksProvider</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">@UIApplicationMain</span>
<span class="kd">final</span> <span class="kd">class</span> <span class="kt">AppDelegate</span><span class="p">:</span> <span class="kt">UIResponder</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">container</span><span class="p">:</span> <span class="kt">AppContainer</span>
    <span class="k">var</span> <span class="nv">booksRenderer</span><span class="p">:</span> <span class="kt">BooksRenderer</span><span class="o">!</span>

    <span class="kd">func</span> <span class="nf">applicationDidFinishLauncherWithOptions</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">container</span> <span class="o">=</span> <span class="kt">AppContainer</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">BooksRenderer</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">provider</span><span class="p">:</span> <span class="kt">BooksProvider</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">provider</span><span class="p">:</span> <span class="kt">BooksProvider</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">provider</span> <span class="o">=</span> <span class="n">provider</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Причем такой подход будет гарантировать вам проверку компилятором. И при этом про AppContainer будет знать только AppDelegate. Да, корневые зависимости в самом AppDelegate’е будут force unwrapped (что исть не хорошо, но лучше я не придумал), но эта вольность доступна только тут.</p>

<p>prootype зависимости в таком подходе можно оформить либо в виде фабрики</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="kt">SomeFactory</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">superDep</span><span class="p">:</span> <span class="kt">SuperDep</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">superDep</span><span class="p">:</span> <span class="kt">SuperDep</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">superDep</span> <span class="o">=</span> <span class="n">superDep</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">makeSomeDep</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">SomeDep</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">SomeDep</span><span class="p">(</span><span class="n">superDep</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>и потом внедрять это фабрику как singleton зависимость туда где нужно генерить prototype’ные, или в виде замыкания</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">SomeFactory</span> <span class="o">=</span> <span class="p">(</span><span class="n">_</span> <span class="nv">superDep</span><span class="p">:</span> <span class="kt">SuperDep</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">SomeDep</span> <span class="p">{</span> <span class="kt">SomeDep</span><span class="p">(</span><span class="n">superDep</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>и также ее внедрять как singleton зависимость.</p>

<p>Но я обещал немножко Swift 5.1 и @PropertyWrapper, их легко сделать так (пусть будет наш пример с ServiceLocator’ом, хотя его можно легко модифицировать):</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">@propertyWrapper</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="kt">Inject</span><span class="o">&lt;</span><span class="kt">Dep</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="kd">private</span> <span class="k">var</span> <span class="nv">kept</span><span class="p">:</span> <span class="kt">Dep</span><span class="p">?</span>

    <span class="kd">public</span> <span class="k">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="kt">Dep</span> <span class="p">{</span>
        <span class="n">kept</span> <span class="p">??</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">dependency</span><span class="p">:</span> <span class="kt">Dep</span> <span class="o">=</span> <span class="kt">ServiceLocator</span><span class="o">.</span><span class="nf">resolve</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">kept</span> <span class="o">=</span> <span class="n">dependency</span>
            <span class="k">return</span> <span class="n">dependency</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">convenience</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="kc">nil</span><span class="p">)</span>
    <span class="p">}</span>
    
    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">ServiceLocator</span> <span class="p">{</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="n">register</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">for</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">resolver</span><span class="p">:</span> <span class="kd">@escaping</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// register</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="n">resolve</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">for</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="p">{</span>
        <span class="c1">// do some magic</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">final</span> <span class="kd">class</span> <span class="kt">BooksRenderer</span> <span class="p">{</span>
    <span class="kd">@Inject</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">provider</span><span class="p">:</span> <span class="kt">BooksProvider</span>
<span class="p">}</span>
</code></pre></div></div>

<p>И вуаля! Однако несмотря на всю прелесть такой магии, есть проблема в месте где творится магия (“do some magic”). Если вы вдруг забыли сделать register, то упс, вы получаете рантайм крэш. И сделать это красиво с compile time check непонятно как, так как регистрация динамическая.</p>

<p>Предлагаю подискутировать, оформляйте issues <a href="https://github.com/mrdekk/mrdekk.github.io">тут</a></p>

<p>P.S.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2019/05/08/clang8-dev-vscode-ubuntu-docker/">
        Разрабатываем и отлаживаем С++ в Docker с помощью VSCode (2019 edition - clang8 lldb)
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">08.05.2019</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#c%2B%2B" title="Pages tagged c++" rel="tag" class="text-success">c++</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#linux" title="Pages tagged linux" rel="tag" class="text-success">linux</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#ubuntu" title="Pages tagged ubuntu" rel="tag" class="text-success">ubuntu</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#gcc" title="Pages tagged gcc" rel="tag" class="text-success">gcc</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#vscode" title="Pages tagged vscode" rel="tag" class="text-success">vscode</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#clang" title="Pages tagged clang" rel="tag" class="text-success">clang</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#lldb" title="Pages tagged lldb" rel="tag" class="text-success">lldb</a>
        </div>
        
      
    </p>

    <p>Какое-то время назад я написал статью <a href="/2018/01/06/vscode-cpp-docker-debugging/">Разрабатываем и отлаживаем С++ в Docker с помощью VSCode</a> в котором для сборки использовался gcc и для отладки gdbserver. В этом обновленном посте хочу затронуть такой же вопрос, но уже на базе clang 8 и lldb-server.</p>

<p>Также в отличии от предыдущей статьи мы не будем каждый раз пересоздавать контейнер, а запустим его один раз и будет с ним работать через <code class="language-plaintext highlighter-rouge">docker exec</code>.</p>

<p>Итак, начнем, Dockerfile</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ubuntu:18.04

RUN apt-get update 
RUN DEBIAN_FRONTEND=noninteractive apt-get install -y build-essential xz-utils curl cmake
RUN DEBIAN_FRONTEND=noninteractive apt-get install -y lldb

RUN curl -SL http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz | tar -xJC . &amp;&amp; \
    mv clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04 clang_8.0.0 &amp;&amp; \
    mv clang_8.0.0 /usr/local

ENV PATH="/usr/local/clang_8.0.0/bin:${PATH}"
ENV LD_LIBRARY_PATH="/usr/local/clang_8.0.0/lib:${LD_LIBRARY_PATH}"

WORKDIR /opt/build
VOLUME ["/opt"]

</code></pre></div></div>

<p>lldb (для lldb-server) используем поставляемый в пакетах (на момент написания статьи для 18.04 это был LLDB 6). Также из пакетов ставим cmake (вроде ничего специфичного пока не надо). clang ставим руками, но уже собранный.</p>

<p>Дальше нам нужен скрипт сборки контейнера (/scripts/docker_build.sh)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

cwd=$(pwd)

docker build \
    -t something/cmaker \
    .
</code></pre></div></div>

<p>И таска для vscode</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "label": "build docker container",
    "command": "${workspaceFolder}/scripts/docker_build.sh"
}
</code></pre></div></div>

<p>после этого нам понадобится запустить контейнер для последующего использования, для этого нам нужен скрипт (/scripts/docker_run.sh). Тут попутно запускается lldb-server, о нем позже:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

cwd=$(pwd)

docker stop сmaker
docker rm сmaker
docker run \
    -dt \
    --name сmaker \
    -p 7000:7000 \
    -p 7001:7001 \
    -p 7002:7002 \
    -p 7003:7003 \
    -v ${cwd}:/opt \
    --privileged \
    something/cmaker \
    "${@}"

</code></pre></div></div>

<p>и таска для vscode</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "label": "run container for future builds",
    "command": "${workspaceFolder}/scripts/docker_run.sh",
    "args": [
        "lldb-server", "platform", "--server", "--listen=0.0.0.0:7000", "-m", "7001", "-M", "7003"
    ],
    "options": {
        "cwd": "${workspaceFolder}"
    }
}
</code></pre></div></div>

<p>После этого можем приступать к сборке проекта. Структуру проекта сразу предусмотрел для многомодульного проекта</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>include
scripts
  docker_build.sh
  docker_run.sh
hword
  include
  CMakeLists.txt
  main.cpp
CMakeLists.txt
Dockerfile
</code></pre></div></div>

<p>Корневой CMakeLists.txt выглядит так</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.0)
project(something)

set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)

set(EXECUTABLE_OUTPUT_PATH ${CMAKE_BINARY_DIR})
set(LIBRARY_OUTPUT_PATH ${CMAKE_BINARY_DIR})

set(PROJECT_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/include)

include_directories("${PROJECT_INCLUDE_DIR}")
include_directories("${PROJECT_SOURCE_DIR}")

add_subdirectory(hword)
</code></pre></div></div>

<p>CMakeLists.txt для hword выглядит так</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.0)
project(hword)

set(PROJECT_INCLUDE_DIR ${PROJECT_SOURCE_DIR}/include)
set(HWORD_VERSION_MAJOR 1)
set(HWORD_VERSION_MINOR 0)

set(PROJECT_HWORD_SRCS
${PROJECT_SOURCE_DIR}/main.cpp
)

include_directories("${PROJECT_BINARY_DIR}")
add_executable(${PROJECT_NAME}_r ${PROJECT_HWORD_SRCS})
include_directories("${PROJECT_INCLUDE_DIR}")
</code></pre></div></div>

<p>Обратите внимание что к имени проекта добавлен постфикс <code class="language-plaintext highlighter-rouge">_r</code></p>

<p>Для примера содержимое main.cpp</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;unistd.h&gt;
#include &lt;limits.h&gt;

#include &lt;iostream&gt;

using namespace std;

static const int HNAME_MAX = 512;
static const int LNAME_MAX = 512;

int main()
{
    char hostname[HNAME_MAX];
    char username[LNAME_MAX];
    gethostname(hostname, HNAME_MAX);
    getlogin_r(username, LNAME_MAX);

    cout &lt;&lt; "hostname: " &lt;&lt; hostname &lt;&lt; ", username: " &lt;&lt; username &lt;&lt; endl;
    return 0;
}
</code></pre></div></div>

<p>Теперь соберем все это дело, запустим и отладим</p>

<p>Нам понадобится скрипт для <code class="language-plaintext highlighter-rouge">docker exec</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/bash

cwd=$(pwd)

docker exec \
    -it \
    cmaker \
    "${@}"

</code></pre></div></div>

<p>Таска для cmake</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "label": "cmake initialize scripts (Makefile, Debug)",
    "command": "${workspaceFolder}/scripts/docker_exec.sh",
    "args": [                
        "cmake", "-G", "Unix Makefiles", 
        "-DCMAKE_BUILD_TYPE=Debug", 
        "-DCMAKE_C_COMPILER=/usr/local/clang_8.0.0/bin/clang",
        "-DCMAKE_CXX_COMPILER=/usr/local/clang_8.0.0/bin/clang++",
        "/opt"
    ],
    "options": {
        "cwd": "${workspaceFolder}"
    }
}
</code></pre></div></div>

<p>Обратите внимание, что тут явным образом указаны пути до компиляторов, это очень важно.</p>

<p>Далее таска для сборки всего проекта и для сборки конкретного</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "label": "make full project",
    "command": "${workspaceFolder}/scripts/docker_exec.sh",
    "args": [
        "make", "-j", "8"
    ],
    "options": {
        "cwd": "${workspaceFolder}"
    }
}
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "label": "make (hword) project",
    "command": "${workspaceFolder}/scripts/docker_exec.sh",
    "args": [
        "make", "-j", "8", "hword_r"
    ],
    "options": {
        "cwd": "${workspaceFolder}"
    }
}
</code></pre></div></div>

<p>И для простого запуска</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "label": "run (hword) project",
    "command": "${workspaceFolder}/scripts/docker_exec.sh",
    "args": [
        "/opt/build/hword_r"
    ]
}
</code></pre></div></div>

<p>С отладкой есть несколько проблем. Во-первых, кроме порта на котором слушает lldb-server надо пробросить еще несколько, на которых будет работать собственно соединение (для этого при запуске контейнера несколько опций <code class="language-plaintext highlighter-rouge">-p</code>). Во-вторых, lldb-server’у этот диапазон портов надо явно задать. И в третьих, надо правильно написать launch.json, выглядит он так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
    "name": "debug: hword",
    "type": "lldb",
    "request": "launch",
    "program": "/opt/build/hword_r",
    "initCommands": [
        "platform select remote-linux",
        "platform connect connect://127.0.0.1:7000"
    ],
    "cwd": "/opt",
    "sourceMap": { 
        "/opt" : "${workspaceFolder}" 
    }
}
</code></pre></div></div>

<p>Жмем F5 и выуля - мы в отладке. Надеюсь это поможет :)</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page2"><i class="fa fa-hand-o-left" ></i> назад</a>
  
  
    <span class="pagination-item newer">вперед <i class="fa fa-hand-o-right" ></i></span>
  
</div>

    </div>

	<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter13259782 = new Ya.Metrika({
                    id:13259782,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/13259782" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-16734363-2', 'auto');
  ga('send', 'pageview');

</script>

    <script src="/public/js/tabs.js"></script>

  </body>
</html>
