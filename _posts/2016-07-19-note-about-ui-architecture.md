---
layout: post
title: Заметки об архитектуре приложений (iOS)
tags:
 - xcode
 - ios
 - architecture
 - swift
---

В последнее время часто стали появляться статьи о том, как же правильно строить архитектуру вашего iOS приложения. Много разного шума о том, что MVC - это не Model View Controller, а Massive View Controller. Стали появляться специализированные сайты, где авторы пытаются подробно разжовывать что и как вы должны делать, чтобы архитектура вашего приложения была правильная и всем было хорошо.

Небольшой реестр того, что заслуживает внимание

 - [Clean Swift, eng](http://clean-swift.com) - тут вам предлагают рецепты (в виде шаблонов xCode), которые помогут вам управлять архитектурой правильно. Основано на VIPER.
 - [Архитектурные паттерны в iOS, рус](https://habrahabr.ru/company/badoo/blog/281162/) - статья на хабре (переводная) где автор разбирает доступные архитектурные паттерны. Полезно почитать для понимания и знания того, что значит MV... (Model View Something)
 - [Clean Architecture, eng](https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) - статья Uncle Bob - основоположника Clean Architecture на базе которого вырос VIPER.

И много еще разного, тут привел что мне самому показалось полезным. Архитектурный паттерн VIPER попытались реализовать и популяризировать. Вот [тут](https://github.com/rambler-ios/Generamba) ребята даже наваяли автогенератор классов-модулей для VIPER для вашего приложения на Swift. Все это выглядит очень и очень интересным, однако дьявол как говориться в деталях. Как только вы начинаете с этим работать в приложении чуть более сложном чем простой Master-Detail (хотя даже и в нем), возникают разного рода проблемы инженерной реализации:

1. Проблемы наследования - ну не будете же вы один и тот же код постоянно писать в каждом контроллере. Поэтому появляются разного рода странные иерархии наследования, когда какой-нибудь простой контроллер наследует поиск только потому, что кому-то этот поиск где-то нужен. Это дело можно попробовать обойти, через реализацию mixin'ов и trait'ов на базе protocol oriented programming, однако отсутствие полноценного множественного наследования в Swift тут же ставит в тупик при попытке реализовать что-то более сложное чем Master-Detail.
2. Проблемы вызова - паттерн рекомендует нам все переходы и обмен между модулями делать через Router, однако при этом роутеру надо столько всего передать или он столько всего должен знать, что мы приходим вдруг к протекающим абстракциям, когда роутер вдруг имеет чуть ли не сильную ссылку на ViewController (ну должен же он сеги как-то инициировать или даже просто сделать pushViewController:animated:)
3. SDK активно сопротивляется. Построение интерфейса основано на использовании Interface Builder'а (отличнейшая штука скажу я вам, но сейчас не про то), в котором центральным объектом является ViewController и точка входа - это ViewController. Поэтому чтобы инженерно реализовать VIPER на iOS ViewController получает много дополнительного кода, просто чтобы реализовать архитектурные паттерны VIPER. И еще как бы очень хотелось использовать Storyboard как определение контейнера для Dependency Injection. Не писать отдельные классы и имеративно регистрировать объекты в них как это предлагают, например, Typhoon и Swinject, а прямо "нарисовать" нужные объекты и их связи прямо в Storyboard'е (тут сделаем реверанс в сторону [Spring Framework](http://spring.io) и его [IoC контейнер на базе XML файлов](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/beans.html)).
4. Управление временем жизни не UI'шных объектов. Например, сервисы или даже сам интерактор. Если, например, объект сервиса, которые дергает запросы к API и в общем является только кодом без состояния - то его конечно можно каждый раз создавать. А вот если у вас сервис держит какой-то кэш, пока работает приложение - то создавать его каждый раз на каждый контроллер уже наверное не сильно хорошо, особенно если это долго. Или, например, в сложном модуле есть несколько подмодулей, которые пользуются одним и тем же сервисом, удобнее было бы, чтобы они разделяли один и тот же экземпляр.

Таким образом, архитектурный паттерн VIPER выглядит очень вкусно в теории, но при реализации на практике сталкивается с рядом инженерных проблем. Евангелисты VIPER предлагают свои решения подобных проблем с разной степенью эффективности. Где-то это достигается некоторым отходом от классической модели (см. clean swift), где-то - большим количеством вспомогательных классов (см. generamba от rambler). Давайте все же попытаемся разобраться с начала. А начало лежит в проблеме, которую принято называть "Massive View Controller".

Проблема "Massive View Controller" состоит в том, что в ViewController'е по мере развития приложения скапливаются не только вопросы собственно управления представлением, а еще ряд других:

1. Запрос данных из внешних источников и внутренних источников - CoreData, API и т.д.
2. Преобразование данных, полученных из внешних источников - не всегда модели данных API и даже CoreData'ы соответствуют той модели, которую надо отобразить на экране. Тут мы получаем преобразование которое можно изобразить как NSManagedObject -> ViewModel, или WebObject -> ViewModel для CoreData и API соответственно.
3. Так как ViewController'у необходимо запрашивать данные, появляются объекты которые это делать позволяют (различные Service'ы, NSFetchedResultsController, и т.д.). И ViewController начинает управлять временем жизни объекта.
4. Управление коммуникациями с другими модулями. Простой пример - pushViewController:animated:

Соответственно, апологеты VIPER придумали для решения каждой из этих задач свой архитектурный модуль:

1. Для запросов данных из внешних источников - Interactor
2. Для преобразования данных в модель представления - Presenter
3. Для управления временем жизни зависимых объектов - Configurator (и иногда Initializer)
4. Для маршрутизации и коммуникации между модулями - Router (или иногда WireFrame)

И из этих архитектурных частей начинают растить классы. Затем из классов иерархии и так далее. Простой пример наверное выглядит так

1. UITableView запрашивает данных у своего UITableViewDataSource данные для ячейки
2. UITableViewDataSource'ом является UIViewController, поэтому он получив вызов делегата транслирует этот вызов в Presenter (1!)
3. Presenter понимает что необходимо запросить данные у бэкенда и транслирует запрос в Interactor (2!)
4. Interactor запрашивает данные у бэкенда, и передает ответ Presenter'у. Опционально можно сохранить в кэш.
5. Presenter транслирует (возможно с преобразование и это важно) полученные от Interactor'а данные во UIViewController (3!)
6. UIViewController отдает полученные от Presenter'а данные в таблицу.

А теперь скажите мне, зачем нам ненужные трансляции вызова 1! и 2!? Ведь UITableViewDataSource'ом UIViewController быть не обязан. Пусть UITableViewDataSource'ом будет сразу тот объект, который носит гордое название Interactor. Для всего этого ему может понадобиться маппер, да и то не всегда, если модели данных API и отображения совпадают - здесь можно использовать одни и те же PONSO объекты. К слову, вы никогда не задумывались, почему существует UITableViewDataSource и UITableViewDelegate? А с учетом состава UITableViewDelegate я бы лично разбил его на две части - собственно UITableViewDelegate и UITableViewStyleConfigurator, но в прочем Apple виднее. Соответственно проблему наполнение таблицы можно решить путем привязки Interactor'а в качестве UITableViewDataSource к таблице прямо из Storyboard'а. И никакого кода формирования таблицы внутри UIViewController'а вообще, исключительно связи в Storyboard'е. А если вы пользуетесь NSFetchedResultsController то и того меньше - вам разве что конфигурация CoreData стэка понадобиться.

А теперь давайте посмотрим в другую сторону. Про mixin'ы и trait'ы. Всего-то надо реализовывать классы по принципе Single Responsibility (привет SOLID) и назначать их в качестве делегатов в нужных местах, большей частью в Storyboard'ах.

Да, прежде чем излагать свое видение инженерной реализации Clean Architecture, стоит сделать важную ремарку. Прославляя Storyboard'ы надо помнить две вещи:

1. Не сделать Massive Storyboard
2. Командная работа над одним Storyboard'ом практически невозможна

Поэтому необходимо иметь ввиду вопросы использования для каждого модуля своего Storyboard'а.

// OLD

![ARCH](/media/images/iosarch/viper2.jpg)

Пояснение к объектам:

 - View - представление, то что непосредственно рисуется на экране. В терминах iOS - это все UIView. Вся задача этой компоненты - нарисоваться на экране правильно.
 - ViewController - контроллер представления, ответственнен за управление представлением, правильного заполнения его полей и является делегатом для событий от представления. В терминах iOS - это все UIViewController. Вся задача этой компоненты - управлять представлением, однако бизнес-логика не для этого слоя.
 - Interactor - компонента которая обрабатывает события, как пользовательские (пользователь нажал кнопку), так и системные (экран появился или вот-вот появится). В терминах iOS нет специального класса для этого, этот класс полностью в вашем ведении. Данные компонент обеспечивает также работу с источником данных и с компонентом маршрутизатора.
 - Presenter - компонент, обеспечивающий связь миров бизнес-логики и представления. Обеспечивает в том числе преобразование из слоя данных в слой представления (Entity -> ViewModel). Также делает представление-специфичную обработку данных (например, группировка для UITableView). В терминах iOS также нет особых классов для этого компонента.
 - Router - маршрутизатор, обеспечивает смену связки V.I.P. (View-Interactor-Presenter) и управляет глобальными вещами для приложения (настройки, авторизация, может быть некоторая обработка ошибок и т.д.). В терминах iOS также нету специального класса, но источником pushViewController:animated: должен быть именно маршрутизатор.

За кадром остались

 - Configurator, компонент который связывает все воедино и может быть точкой внедрения DI
 - Initializer, специальный объект, который дает вам точку входа для вызова конфигуратора, если вы работаете через Storyboard'ы например.

Кроме того, не все линии одинакового цвета, это тоже кой чего значит:

 - оранжевые линии - тесная связь UIView и UIViewController. С точки зрения ViewController'а в сторону View ("управляет") - хранит ссылки и обеспечивает настройку через вызовы сеттеров или просто функций. С точки зрения View в сторону ViewController'а ("события") - ViewController является делегатом для View и является первой точкой приема событий.
 - красные линии - преобразованные в специальные DataTransfer Objects (DTO) "события" от представления, которые должны быть обработаны бизнес-логикой (т.е. в нашем случае интерактором). Это могут быть как просто скалярные объекты (числа, строки и т.д.), так и простые  (POCO, Swift struct, ...) объекты. Главное чтоб эти объекты не организовывали протекающие абстракции.
 - синии линии - объекты, которые понимает интерактор, которые необходимо отобразить в слое представления. Интерактор по понятным причинам не может и не должен знать о том, как устроено представление, поэтому он передает презентеру объекты для того, чтобы презентер их правильно преобразовал и отобразил на представлении.
 - зеленые линии - объекты (ViewModel) представления, которые понимает контроллер и которые контроллер использует для настройки вьюшек.
 - черные линии - взаимодействие интерактора со специфичными сервисами (сеть, CoreData и т.д.) и передача команд маршрутизатору, когда команда находится в ведении маршрутизатора или какого-то другого интерактора.

Таким образом

 1. Представление (V), интерактор (I) и презентер (P) образуют цикл. Данные могут передаваться только в направлении указанном стрелочками. Благодаря тому, что поток данных однонаправленный, они могут быть иммутабельными, что хорошо сказывает на многопоточности например.
 2. Представление, интерактор и презентер напрямую друг о друге ничего не знают - они взаимодействуют через интерфейсы (на схеме обозначены зелеными квадратами). Это позволяет их заменять по отдельности, тестировать их по отдельности а также открывает путь к реализации паттерна DI в рамках конфигуратора.

To be continue...
(Статья будет пополняться, можете принять в этом участие)

// INFO

Storyboard as DI container

- NSObject heir
- KVC-complaint
- initWithCoder
- IBOutlet
