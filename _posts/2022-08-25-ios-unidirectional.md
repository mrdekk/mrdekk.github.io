---
layout: post
title: iOS. Unidirectional architecture
tags:
 - swift
 - ios
 - architecture
 - tca
 - udf
 - mvi
---

Итак, давайте сегодня поговорим об архитектурах. Хочется иметь некоторую статейку, на которую можно ссылаться при обсуждениях, и которую можно при необходимости пополнять. В рамках данной статьи поговорим про архитектуру, известную под многими именами: TCA (The Composable Architecture, хорошо проработанную ребятами из [pointfree](https://pointfree.co)), UDF (Unidirectional Data Flow) или MVI (Model-View-Intent но под этим вы можете нагуглить огромный спектр разного). 

В рамках данной статьи я расскажу, скажем так, свое видение, котоорое сформировалась в ходе попыток применить идеи в ряда "боевых" проектов.

Но для начала, давайте обсудим некоторые принципы, на которых мы будем строить наше обсуждение.

## Компонент

Самым важным из них мне кажется идея компонента.

![Компонент](/media/images/ios-udf/component.png)

Что дает нам компонент? Для начала это некоторая сущность, призванная решить одну конкретную задачу (не забываем про [SRP](https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности)). Важно чтобы он решал одну конкретную задачу. Для того, чтобы иметь возможность давать примеры, предположим что наш компонент - _Бариста_, его задача - _варить кофе_. 

Итак, компонент должен выполнять какую-то одну задачу, в ходе этой задачи появляются результаты работы - **выходные данные**. Это результат работы компонента. Для нашего примера с баристой, результат работы - _конкретная чашка кофе_. Таких чашек может быть несколько (странно было бы иметь баристу, которые сварил один кофе и на этом все).

Однако, для того, чтобы компонент мог выполнить свою задачу, ему нужно:

1. Дать некоторые **входные данные**. В примере с баристой - это _желаемый тип кофе (капучино)_, _уровень сахара_, _наличие молока_ и т.д.
2. Предоставить некоторые **зависимости**. В примере с баристой - это _кофемашина_, _зерна кофе_ и т.д.
3. Предоставить некоторую **конфигурацию**, которая тоже является неким вариантом входных данных. В примере с баристой - это _сорта кофе, которые он сегодня может варить_.

И что еще более важно - вся эта четверка должна быть **явно выражена в публичном контракте компонента**. Чтобы пользователю вашего компонента не приходилось вникать в детали его реализации.

Как может компонент быть выражен в виде кода, так как речь про iOS будем использовать язык swift:

```swift
class Component {

    private(set) var out: Result<Out1, Error>?

    private let in1: In1
    private let deps: Deps

    init(in1: In1, deps: Deps) {
        self.in1 = in1
        self.deps = deps
    }

    func doThePurpose(in2: In2) -> Result<Out2, Error> {
        // use in1, in2, deps to construct Out1 & Out2
        self.out = .success("")
        return ""
    }
}
```

В данном примере есть два способа получить входные данные, два способа получить выходные результаты и один способ передать зависимости.

Давайте сначала про зависимости. Мы считаем, что компонент не может выполнять свою работу без переданных ему зависимостей, поэтому требуем их в инициализаторе (initializer injection). Это требуется для того, чтобы у нас не было возможности оказаться в ситуации, когда компонент просят выполнить какую-то работу (doThePurpose), но он не может, потому что конкретную зависимость не передали и единственное что он может сделать - упасть с рантайм ошибкой (крэш).

Зависимости лучше передавать через протокол, чтобы конкретный компонент не знал конкретный класс зависимости, а только ее контракт.

Теперь про входные данные, есть два способа их передать - через инициализатор и непосредственно при выполнении работы. Чуть выше мы обсуждали, что у нас могут быть конфигурационные параметры и собственно входные данные. Так вот, скорее кажется, что конфигурационные параметры передаются через инициализатор (in1: In1) а входные данные непосредственно в реализацию "призвания" конкретного компонента (in2: In2). В примере с баристой, in1 - это описание типов кофе, который может сегодня варить бариста, а in2 - параметры непосредственного запроса (капуччино, без сахара).

Похожая ситуация с выходными данными - мы можем вернуть их из конкретной функции и как результат работы самого класса. Соответственно, результат одного заказа (конкретная кружка кофе) возвращается непосредственно из функции (Out2), а результат работы всей сущности (например _заработанные за день денги_) уже являются свойством самого инстанса (Out1), хотя тут строгой разницы в целом нет. В Out1 может также находится некоторое "наблюдаемое состояние" самой сущности, пригодной для внешнего потребления (но не стоит забывать что оно при этом становится частью публичного контракта).

## Однонаправленный поток данных (Unidirectional Flow)

Чтобы непосредственно перейти к рассмотрению архитектуры нам понадобятся еще "запчасти". Теперь давайте рассмотрим однонаправленный поток данных.

Если мы глянем на классическую iOS архитектуру Apple MVC, то увидим следующую картину:

![AppleMVC](/media/images/ios-udf/applemvc.png)

Что здесь важно? Между Model и Controller и между Controller и View установлен так называемый "двунаправленный" поток данных. Что здесь плохого скажете вы? Тут кажется есть две проблемы:

1. Возможно кэширование какого-то состояния в промежуточных этапах (в Controller'е например, здравствуй Massive View Controller)
2. Некоторые компоненты выполняют две задачи (контроллер в данном случае управляет двумя потоками от модели к вью и от вью к модели)

Как же должен выглядеть однонаправленных поток, в уже ставших некоторым образом "классических" трудах по архитектуростроению был такой подход (VIP архитектура так называемая):

![VIP цикл](/media/images/ios-udf/vip.png)

Здесь все выглядит интереснее - поток данных происходит только в одном направлении и каждый из компонентов решает свою выделенную задачу. Таким образом на пути данных мы имеем только одну дорогу и ее проще контроллировать.




