<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <meta name='yandex-verification' content='4a3e9fdb2ed97f52' />

  <title>
    
      Главная &middot; MrDekk
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/hyde.css">
  <link rel="stylesheet" href="/public/css/mrdekk.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Noto+Serif:400,400italic,700,700italic&subset=latin,cyrillic-ext,latin-ext,cyrillic'>
  <link rel="stylesheet" href="/public/css/font-awesome.min.css" >

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
                                 <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  <link rel="stylesheet" href="/public/css/tabs.css">
</head>


  <body>

    <div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
	  <img class="profile" alt="my-profile" src="/media/images/brujo.jpg" width="120px">
      <h1>MrDekk</h1>
      <p class="description">Время - лучший учитель! Жаль, что оно убивает своих учеников...</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
        <a href="/"><i class="fa fa-home" ></i></a>
      </li>

      

      
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/about/">Кто здесь?</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
          
        
      
        
      
        
      
        
          
        
      
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/tags/">Метки</a>
            </li>
          
        
      
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/useful/">Полезное</a>
            </li>
          
        
      
        
      
        
          
        
      
        
          
            <li class="sidebar-nav-item">
              <a href="/awesome/">Awesome Stars</a>
            </li>
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
        
          
        
      
    </ul>

	<p class="social-icons">
		<!-- <a href="/search"><i class="fa fa-search fa-2x"></i></a> -->
		<a href="https://github.com/mrdekk"><i class="fa fa-github fa-2x"></i></a>
		<a href="https://twitter.com/mrdekk"><i class="fa fa-twitter fa-2x"></i></a>
		<a href="/atom.xml"><i class="fa fa-rss fa-2x"></i></a>
	</p>

    <p>&copy; 2025. All rights reserved.</p>
  </div>
</div>


    <div class="content container">
      <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2016/06/07/usefull-xcode-flags/">
        Полезные флаги xCode
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">07.06.2016</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#xcode" title="Pages tagged xcode" rel="tag" class="text-success">xcode</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#ios" title="Pages tagged ios" rel="tag" class="text-success">ios</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#objc" title="Pages tagged objc" rel="tag" class="text-success">objc</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#swift" title="Pages tagged swift" rel="tag" class="text-success">swift</a>
        </div>
        
      
    </p>

    <p>Некоторые полезные в работе флаги</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-UIViewShowAlignmentRects YES</code> - показывает желтыми линиями frame rect’ы, которые удобно использовать для отладки</li>
  <li><code class="language-plaintext highlighter-rouge">-com.apple.CoreData.ConcurrencyDebug 1</code> - “стреляет” assert’ами, когда NSManagedObjectContext или другие примитивы CoreData используются в неправильном потоке</li>
  <li><code class="language-plaintext highlighter-rouge">-com.apple.CoreData.SQLDebug 1</code> - пишет в лог все sqlite запросы, которые делает CoreData в процессе своей работы</li>
  <li><code class="language-plaintext highlighter-rouge">-Name:OS_ACTIVITY_MODE disable</code> - отключает вывод системного лога в debug окно Xcode 8</li>
  <li><code class="language-plaintext highlighter-rouge">DYLD_PRINT_STATISTICS 1</code> - выводит данные о загрузке внешних библиотек (и не только)</li>
  <li><code class="language-plaintext highlighter-rouge">SWIFT_DEBUG_IMPLICIT_OBJC_ENTRYPOINT 1-3</code> - выводит лог использования @objc inference</li>
</ul>

<p>Некоторые полезные флаги компилятора</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">-Wglobal-constructors</code> - показывает использование нетривиальных конструкторов С++ при инициализации глобальных объектов</li>
</ul>

<p>Разные полезные штуки при работе с LLDB</p>

<ul>
  <li>
    <p>Показать историю аллокаций по адресу в памяти, надо в консоли отладчика сделать так</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (lldb) command script import lldb.macosx.heap
  (lldb) malloc_info --stack-history 0x10010d680
</code></pre></div>    </div>
  </li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2016/05/23/github-sync-forked-repo-with-upstream/">
        GitHub - синхронизируем forked репозиторий с upstream
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">23.05.2016</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#git" title="Pages tagged git" rel="tag" class="text-success">git</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#github" title="Pages tagged github" rel="tag" class="text-success">github</a>
        </div>
        
      
    </p>

    <p>Задача: синхронизировать форкнутый репозиторий с тем, от которого он был форкнут и забрать оттуда новые изменения.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Добавляем новый удаленный репозиторий</span>
<span class="nv">$ </span>git remote add upstream https://github.com/whoever/whatever.git

<span class="c"># Загружаем все ветки для отслеживания</span>
<span class="nv">$ </span>git fetch upstream

<span class="c"># Убеждаемся, что мы на своем master'е</span>
<span class="nv">$ </span>git checkout master

<span class="c"># Перезаписываем нашу ветку master чтобы те наши коммиты, которые не входят в удаленный мастер</span>
<span class="c"># оказали на нем:</span>
<span class="nv">$ </span>git rebase upstream/master

<span class="c"># Force push необходим для перезаписи истории ветки на вашем репозитории</span>
<span class="nv">$ </span>git push <span class="nt">-f</span> origin master
</code></pre></div></div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2016/05/19/gcd-handbook/">
        Поваренная книга GCD
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">19.05.2016</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#gcd" title="Pages tagged gcd" rel="tag" class="text-success">gcd</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#recipe" title="Pages tagged recipe" rel="tag" class="text-success">recipe</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#handbook" title="Pages tagged handbook" rel="tag" class="text-success">handbook</a>
        </div>
        
      
    </p>

    <p><em>GCD - Grand Central Dispatch - библиотека от Apple для iOS и OS X для работы с примитивами многозадачности. На просторах интернета наткнулся на <a href="http://khanlou.com/2016/04/the-GCD-handbook/">статью</a> с некоторыми рецептами по работе с GCD. Статья на английском и очень интересная. Здесь хочу предложить вам ее вольный перевод. Далее повествование ведется от лица автора.</em></p>

<p>Grand Central Dispatch или GCD - очень мощная штуковина. Она предоставляет в ваше распоряжение низкоуровневые конструкции, такие как очереди и семафоры, которые вы можете комбинировать различными путями для получения многотопоточных эффектов. Однако, основанное на языке С API, на первый взгляд кажется книгой заклинаний и не сразу понятно, как собрать эти низкоуровневые кубики в нечто полезное высокоуровневое. В этой статье я постараюсь описать некоторые полезные конструкции, которые вы сможете использовать в своих приложениях.</p>

<h2 id="выполнение-задач-в-фоне">Выполнение задач в фоне</h2>

<p>Пожалуй самое просто что может потребоваться - это выполнить некоторую работу в фоновом потоке, а затем вернуть результат в основной поток для отображения, так как такие компоненты как UIKit могут работать исключительно из главного потока.</p>

<p>В этой статье для отображения чего-то, что занимает много времени для выполнения будут использоваться функции вида <code class="language-plaintext highlighter-rouge">doSomeExpensiveWork()</code></p>

<p>И так, чтобы выполнить что-то в фоновом потоке, а затем вернуться в основной надо сделать примерно так:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">defaultPriority</span> <span class="o">=</span> <span class="kt">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>
<span class="k">let</span> <span class="nv">backgroundQueue</span> <span class="o">=</span> <span class="nf">dispatch_get_global_queue</span><span class="p">(</span><span class="n">defaultPriority</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="nf">dispatch_async</span><span class="p">(</span><span class="n">backgroundQueue</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">result</span> <span class="o">=</span> <span class="nf">doSomeExpensiveWork</span><span class="p">()</span>
  <span class="nf">dispatch_async</span><span class="p">(</span><span class="nf">dispatch_get_main_queue</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// используем как-нибудь `result`</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>На практике, очень редко используются другие приоритеты, нежели <code class="language-plaintext highlighter-rouge">DISPATCH_QUEUE_PRIORITY_DEFAULT</code>. Функция <code class="language-plaintext highlighter-rouge">dispatch_get_global_queue</code> возвращает очередь, задания из которой могут выполняться на сотнях разных потоков. Если вам требуется, чтобы какие-то тяжелые задачи всегда выполнялись на какой-то определенной фоновой очереди, вы можете создать свою с помощью <code class="language-plaintext highlighter-rouge">dispatch_queue_create</code>. Она принимает имя очереди и флаг того, должна быть очередь последовательной (serial) или конкурентной (concurrent).</p>

<p>Важно, чтобы каждый вызов использовал dispatch_<strong>a</strong>sync, а не dispatch_sync. dispatch_async возвращает управление до того момента, как блок будет выополнен. Напротив, dispatch_sync дожидается выполнения блока перед тем как вернуть управление. Внутренний вызов в dispatch_sync может использовать dispatch_sync (так как в общем все равно когда вернется управление), но внешний вызов должен быть dispatch_async, потому что иначе главный поток будет заблокирован.</p>

<h2 id="singleton-паттерн-одиночка">Singleton (паттерн одиночка)</h2>

<p>С помощью dispatch_once вы можете создавать объекты паттерна “одиночка”. В swift это уже не так важно, так как есть более простые способы, однако для информации все же паттерн приводится ниже (ну и для Objective-C это по прежнему важно).</p>

<div class="language-objc highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">+</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span> <span class="n">sharedInstance</span> <span class="p">{</span>  
  <span class="k">static</span> <span class="n">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>  
  <span class="k">static</span> <span class="n">id</span> <span class="n">sharedInstance</span><span class="p">;</span>  
  <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>  
    <span class="n">sharedInstance</span> <span class="o">=</span> <span class="p">[[</span><span class="n">self</span> <span class="nf">alloc</span><span class="p">]</span> <span class="nf">init</span><span class="p">];</span>  
  <span class="p">});</span>  
  <span class="k">return</span> <span class="n">sharedInstance</span><span class="p">;</span>  
<span class="p">}</span>  
</code></pre></div></div>

<h2 id="сглаживаем-о_о-блок-обратного-вызова">Сглаживаем О_О блок обратного вызова</h2>

<p><em>Сглаживание конечно не совсем верный перевод для термина flatten, который еще можно перевести как выравнивание, но за неимением лучшей альтернативы пока так, можете предложить лучше, если знаете. (прим. переводчика)</em></p>

<p>А вот тут уже становится интересно. С помощью семафора, мы можем заблокировать поток на некоторое количество времени, пока не получим сигнал от другого потока. Семафоры, как и другие примитивы GCD, потокобезопасные, поэтому их можно вызывать где угодно.</p>

<p>Семафоры можно использовать тогда, когда вы имеете асинхронное API но хотите сделать синхронный вызов, но API менять по какой-то причине не можете.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// на фоновой очереди</span>
<span class="n">dispatch_semaphore_t</span> <span class="n">semaphore</span> <span class="o">=</span> <span class="nf">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="nf">doSomeExpensiveWorkAsynchronously</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">)</span>
<span class="p">}</span>

<span class="nf">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="kt">DISPATCH_TIME_FOREVER</span><span class="p">)</span>
<span class="c1">// тяжелая асинхронная обработка закончена</span>
</code></pre></div></div>

<p>С помощью вызова <code class="language-plaintext highlighter-rouge">dispatch_semaphore_wait</code> вы блокируете поток до тех пор, пока где-либо не будет вызван сигнал <code class="language-plaintext highlighter-rouge">dispatch_semaphore_signal</code>. Это означает, что сигнал должен быть вызван из другого потока, так как текущий заблокирован. И более, <strong>вы никогда не должны вызывать wait из главного потока, только из фонового</strong>.</p>

<p>Вы можете выбрать любой промежуток времени при вызове <code class="language-plaintext highlighter-rouge">dispatch_semaphore_wait</code> (это будет своего рода таймаут), но обычно передается <code class="language-plaintext highlighter-rouge">DISPATCH_TIME_FOREVER</code>.</p>

<p>Может быть не совсем понятно зачем вам делать синхронный вызов из функции, которая <strong>уже</strong> содержит блок обратного вызова, но если вам это потребуется, вы знаете как это сделать. Однако, есть один случай, когда вам это может понадобиться - вам необходимо выполнить ряд асинхронных операций <strong>последовательно</strong>. Для того, чтобы облегчить использование, можно написать простой класс для абстракции - AsyncSerialWorker:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">typealias</span> <span class="kt">DoneBlock</span> <span class="o">=</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span>
<span class="kd">typealias</span> <span class="kt">WorkBlock</span> <span class="o">=</span> <span class="p">(</span><span class="kt">DoneBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span>

<span class="kd">class</span> <span class="kt">AsyncSerialWorker</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">serialQueue</span> <span class="o">=</span> <span class="nf">dispatch_queue_create</span><span class="p">(</span><span class="s">"com.khanlou.serial.queue"</span><span class="p">,</span> <span class="kt">DISPATCH_QUEUE_SERIAL</span><span class="p">)</span>

  <span class="kd">func</span> <span class="nf">enqueueWork</span><span class="p">(</span><span class="nv">work</span><span class="p">:</span> <span class="kt">WorkBlock</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">dispatch_async</span><span class="p">(</span><span class="n">serialQueue</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">semaphore</span> <span class="o">=</span> <span class="nf">dispatch_semaphore_create</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
      <span class="nf">work</span><span class="p">({</span>
        <span class="nf">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">)</span>
      <span class="p">})</span>
      <span class="nf">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="kt">DISPATCH_TIME_FOREVER</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Этот небольшой класс создает последовательную очередь и позволяет вам передать в нее блок на обработку. Объект WorkBlock дает вам DoneBlock для вызова, когда работа будет закончена, который в свою очередь отправит сигнал семафору и очередь отправит на обработку следующий блок.</p>

<h2 id="ограничиваем-количество-одновременно-выполняемых-блоков">Ограничиваем количество одновременно выполняемых блоков</h2>

<p>В предыдущем примере, семафор использовался как обычный флаг, но он может быть использован как счетчик для ограниченных ресурсов. Например, вы хотите открыть определенное количество подключений к определенному ресурсу. Вам поможет в этом следующий класс:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">LimitedWorker</span> <span class="p">{</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">concurrentQueue</span> <span class="o">=</span> <span class="nf">dispatch_queue_create</span><span class="p">(</span><span class="s">"com.khanlou.concurrent.queue"</span><span class="p">,</span> <span class="kt">DISPATCH_QUEUE_CONCURRENT</span><span class="p">)</span>
  <span class="kd">private</span> <span class="k">let</span> <span class="nv">semaphore</span><span class="p">:</span> <span class="n">dispatch_semaphore_t</span>

  <span class="nf">init</span><span class="p">(</span><span class="nv">limit</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">semaphore</span> <span class="o">=</span> <span class="nf">dispatch_semaphore_create</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">enqueueWork</span><span class="p">(</span><span class="nv">work</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
    <span class="nf">dispatch_async</span><span class="p">(</span><span class="n">concurrentQueue</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">dispatch_semaphore_wait</span><span class="p">(</span><span class="n">semaphore</span><span class="p">,</span> <span class="kt">DISPATCH_TIME_FOREVER</span><span class="p">)</span>
      <span class="nf">work</span><span class="p">()</span>
      <span class="nf">dispatch_semaphore_signal</span><span class="p">(</span><span class="n">semaphore</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Этот пример взят из <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24">Apple Concurrency Programming Guide</a>. Они могут объяснить что происходит лучше чем я:</p>

<blockquote>
  <p>Когда вы создаете семафор, вы можете задать количество доступных ресурсов. Это значение становится первичным значением счетчика для семафора. Каждый раз когда вы вызываете wait на семафоре, <code class="language-plaintext highlighter-rouge">dispatch_semaphore_wait</code> уменьшает счетчик на единицу. Если полученное значение отрицательно, функция блокирует ваш поток. С другой стороны, вызов функции <code class="language-plaintext highlighter-rouge">dispatch_semaphore_signal</code> увеличивает счетчик на единицу для уведомления о том, что ресурс освобожден. Если есть заблокированные задачи, ожидающие доступ к ресурсу, одна из них разблокируется и начнет выполнение.</p>
</blockquote>

<p>Эффект аналогичен установке значения <code class="language-plaintext highlighter-rouge">maxConcurrentOperationCount</code> объекта <code class="language-plaintext highlighter-rouge">NSOperationQueue</code>. Если вы используете сырой GCD вместо NSOperationQueue, вы можете использовать семафоры для ограничения количества одновременно выполняемых блоков.</p>

<p><strong>ВАЖНО!</strong> Здесь присутствует один важный момент. Каждый раз когда вы вызываете enqueueWork и вы достигли ограничения семафора - создается новый поток. Если у вас небольшой лимит и много задач для размещения в очередь, вы таким образом создадите огромное количество заблокированных потоков. Используйте профайлер и избегайте узких мест.</p>

<h2 id="ожидаем-единого-завершения-нескольких-асинхронных-операций">Ожидаем единого завершения нескольких асинхронных операций</h2>

<p>Если у вас есть несколько асинхронно выполняемых блоков и вы хотите дождаться их общего завершения, вы можете использовать группу. <code class="language-plaintext highlighter-rouge">dispatch_group_async</code> позволяет вам добавить задачу в очередь (задача в блоке однако должна быть синхронной), и ведет учет количество добавленных задач. Важно, что одна и та же группу может добавлять задачи в несколько разных очередь и учитывать все из них. Когда все задачи в группе будут выполнены, вызывается блок, переданный в <code class="language-plaintext highlighter-rouge">dispatch_group_notify</code> - это своего рода блок обратного вызова на всю группу.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="nf">dispatch_group_create</span><span class="p">()</span>
<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">someArray</span> <span class="p">{</span>
  <span class="nf">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">backgroundQueue</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">performExpensiveWork</span><span class="p">(</span><span class="nv">item</span><span class="p">:</span> <span class="n">item</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nf">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nf">dispatch_get_main_queue</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// все задачи выполнены</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Это хороший пример сглаживания функции, которая имеет блок обратного вызова. Существует другой, более ручной способ использования групп, особенно, если часть ваших фоновых вычислений уже асинхронная.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// этот код должен выполняться на фоновом потоке</span>
<span class="n">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="nf">dispatch_group_create</span><span class="p">()</span>
<span class="k">for</span> <span class="n">item</span> <span class="k">in</span> <span class="n">someArray</span> <span class="p">{</span>
  <span class="nf">dispatch_group_enter</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
  <span class="nf">performExpensiveAsyncWork</span><span class="p">(</span><span class="nv">item</span><span class="p">:</span> <span class="n">item</span><span class="p">,</span> <span class="nv">completionBlock</span><span class="p">:</span> <span class="p">{</span>
    <span class="nf">dispatch_group_leave</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="nf">dispatch_group_wait</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="kt">DISPATCH_TIME_FOREVER</span><span class="p">)</span>

<span class="c1">// все фоновые задачи в группе выполнены</span>
</code></pre></div></div>

<p>Этот пример сложнее, но если пройтись по нему строка за строкой то все станет понятно. Как и семафор, группа содержит потокобезопасный внутренний счетчик, которым можно манипулировать. С помощью него вы можете гарантировать, что блок обратного вызова будет вызван после завершения всех долготекущий операций. Вызов “enter” увеличивает счетчик, вызов “leave” - уменьшает. <code class="language-plaintext highlighter-rouge">dispatch_group_async</code> скрывает для вас все детали, поэтому предпочтительнее.</p>

<p>Последнее в этом примере - это вызов wait, который блокирует поток и ожидает момента когда счетчик достигнет 0. Важно! Вы моежет использовать <code class="language-plaintext highlighter-rouge">dispatch_group_notify</code> даже если вы используете enter/leave. Обратное также верно - вы можете использовать <code class="language-plaintext highlighter-rouge">dispatch_group_wait</code> даже при использовании <code class="language-plaintext highlighter-rouge">dispatch_group_async</code>.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">dispatch_group_wait</code> также как и <code class="language-plaintext highlighter-rouge">dispatch_semaphore_wait</code> принимает в качестве аргумента таймаут. Опять же, редко возникает нужда в чем-то отличном от <code class="language-plaintext highlighter-rouge">DISPATCH_TIME_FOREVER</code>. И так же как и в случае <code class="language-plaintext highlighter-rouge">dispatch_semaphore_wait</code> никогда не вызывайте <code class="language-plaintext highlighter-rouge">dispatch_group_wait</code> на главном потоке.</p>

<p>Самое главное отличие между этими двумя подходами в том, что notify можно вызывать непосредственно на главном потоке, а wait необходимо использовать на фоновом (как минимум wait, так как этот вызов блокирует текущую очередь).</p>

<h2 id="очереди-изоляции">Очереди изоляции</h2>

<p>Словарь (и массив) в Swift - типы значений. Когда они изменяются, их ссылка полностью заменяется новой копией структуры. Однако, ввиду того что обновление полей экземпляра (ivar) объектов Swift не является атомарной операцией, она не является потокобезопасной. Два потока могут обновить словарь (например, добавить значение) в одно и то же время, и оба попытаются записать один и тот же блок памяти, что приведет к ее повреждению. Для того, чтобы обеспечить потокобезопасность можно использовать очереди изоляции.</p>

<p>Давайте сформируем коллекцию объектов, которая будет представлять собой словарь, где ключом будет ID объекта, а значением - сам объект.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">IdentityMap</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Identifiable</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">dictionary</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">T</span><span class="o">&gt;</span><span class="p">()</span>

  <span class="kd">func</span> <span class="nf">object</span><span class="p">(</span><span class="n">forID</span> <span class="kt">ID</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">dictionary</span><span class="p">[</span><span class="kt">ID</span><span class="p">]</span> <span class="k">as</span> <span class="kt">T</span><span class="p">?</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">addObject</span><span class="p">(</span><span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dictionary</span><span class="p">[</span><span class="n">object</span><span class="o">.</span><span class="kt">ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">object</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Этот объект фактически является оберткой над словарем. Если наша функция addObject будет вызвана из нескольких потоков в одно и то же время, память будет нарушена, так как потоки будут использовать одну и ту же ссылку. Эта известная <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D1%87%D0%B8%D1%82%D0%B0%D1%82%D0%B5%D0%BB%D1%8F%D1%85-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D0%B5%D0%BB%D1%8F%D1%85">задача о читателях-писателях</a>. В кратце, мы можем иметь несколько читателей в одно и то же время, но только одного писателя в каждый конкретный момент времени.</p>

<p>К счастью, GCD дает нам замечательные инструменты для этого случая. Нам доступны следующие инструменты для решения этой задачи:</p>

<ul>
  <li>dispatch_sync</li>
  <li>dispatch_async</li>
  <li>dispatch_barrier_sync</li>
  <li>dispatch_barrier_async</li>
</ul>

<p>Идеальным случаем будет:</p>

<ul>
  <li>чтения случаются синхронно и конкурентно</li>
  <li>записи должны быть асинхронными и должны быть единственной задачей, которая работает с ссылкой</li>
</ul>

<p>Барьеры GCD делают одну интересную вещь - они ожидают момента, когда очередь будет полностью пуста, перед тем как выполнить блок. С помощью барьеров для наших чтений мы ограничим доступ к словарю и обеспечим гарантию того, что никакая запись не будет проводиться одновременно с чтением или другой записью.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">IdentityMap</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span> <span class="kt">Identifiable</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">dictionary</span> <span class="o">=</span> <span class="kt">Dictionary</span><span class="o">&lt;</span><span class="kt">String</span><span class="p">,</span> <span class="kt">T</span><span class="o">&gt;</span><span class="p">()</span>
  <span class="k">let</span> <span class="nv">accessQueue</span> <span class="o">=</span> <span class="nf">dispatch_queue_create</span><span class="p">(</span><span class="s">"com.khanlou.isolation.queue"</span><span class="p">,</span> <span class="kt">DISPATCH_QUEUE_CONCURRENT</span><span class="p">)</span>

  <span class="kd">func</span> <span class="nf">object</span><span class="p">(</span><span class="n">withID</span> <span class="kt">ID</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">T</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">T</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span>
    <span class="nf">dispatch_sync</span><span class="p">(</span><span class="n">accessQueue</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">dictionary</span><span class="p">[</span><span class="kt">ID</span><span class="p">]</span> <span class="k">as</span> <span class="kt">T</span><span class="p">?</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">addObject</span><span class="p">(</span><span class="nv">object</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">dispatch_barrier_async</span><span class="p">(</span><span class="n">accessQueue</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">dictionary</span><span class="p">[</span><span class="n">object</span><span class="o">.</span><span class="kt">ID</span><span class="p">]</span> <span class="o">=</span> <span class="n">object</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Функция <code class="language-plaintext highlighter-rouge">dispatch_sync</code> отправит блок в нашу очередь изоляции и будет дожидаться окончания перед тем как вернуть выполнение. После этого, мы будем иметь результат нашего чтения. Если не делать вызов синхронным, тогда потребуется введение блока обратного вызова. Благодаря тому, что очередь конкурентная, такие синхронные чтения могут выполняться по несколько штук параллельно.</p>

<p>Функция <code class="language-plaintext highlighter-rouge">dispatch_barrier_async</code> отправит блок в очередь изоляции. Async означает что управление будет возвращено до того, как блок фактически выполниться (т.е. выполниться запись). Это хорошо для проиводительности, но имеет и обратную сторону медали - чтение сразу после записи может вернуть старые данные.</p>

<p>Барьерная часть <code class="language-plaintext highlighter-rouge">dispatch_barrier_async</code> означает, что блок не будет выполнен до тех пор, пока каждый блок в очереди не закончит свое выполнение. Другие блоки будут размещены после барьерного и выполняться после того, как выполнится барьерный.</p>

<h2 id="таймер-на-gcd">Таймер на GCD</h2>

<p>Иногда требуется периодическое выполнение какой-то функциональности и как правило для этого используют NSTimer. Однако таймер можно сделать и на GCD примерно вот так:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">timer</span><span class="p">:</span> <span class="n">dispatch_source_t</span><span class="p">?</span>

<span class="kd">func</span> <span class="nf">createTimer</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="nf">dispatch_get_global_queue</span><span class="p">(</span><span class="kt">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">double</span> <span class="n">secondsToFire</span> <span class="o">=</span> <span class="mf">1.000</span><span class="n">f</span><span class="p">;</span>
  
  <span class="k">self</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="nf">dispatch_source_create</span><span class="p">(</span><span class="kt">DISPATCH_SOURCE_TYPE_TIMER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">queue</span><span class="p">)</span>
  <span class="k">if</span> <span class="k">let</span> <span class="nv">timer</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">timer</span> <span class="p">{</span>
    <span class="nf">dispatch_source_set_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">,</span> <span class="kt">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="n">secondsToFire</span> <span class="o">*</span> <span class="kt">NSEC_PER_SEC</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="n">ull</span> <span class="o">*</span> <span class="kt">NSEC_PER_SEC</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
    <span class="nf">dispatch_source_set_event_handler</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// do something useful</span>
    <span class="p">}</span>
    <span class="nf">dispatch_resume</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">releaseTimer</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">guard</span> <span class="k">let</span> <span class="nv">timer</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">timer</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
  <span class="nf">dispatch_source_cancel</span><span class="p">(</span><span class="n">timer</span><span class="p">)</span>
  <span class="n">timer</span> <span class="o">=</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="post-scriptum">Post Scriptum</h2>

<p>Фреймворк GCD содержит много низкоуровневых примитивов. С их помощью мы смогли построить высокоуровневые конструкции. Если вам известны какие-то другие высокоуровневые конструкции не упомянутые здесь, будут рад их услышать <em>(вы можете сделать PR тут или отправить напрямую автору. прим. переводчика)</em></p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2016/05/15/jekyll-usefull-stuff/">
        Полезное для jekyll
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">15.05.2016</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#jekyll" title="Pages tagged jekyll" rel="tag" class="text-success">jekyll</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#stuff" title="Pages tagged stuff" rel="tag" class="text-success">stuff</a>
        </div>
        
      
    </p>

    <ul>
  <li><a href="https://github.com/jneen/rouge/wiki/List-of-supported-languages-and-lexers">список доступных подсветок синтаксиса для rouge</a></li>
  <li><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet">github flavored markdown cheatsheet</a></li>
</ul>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2016/05/11/symbolicate-crash-log/">
        Символификация crash-дампа iOS
      </a>
    </h1>

    <i class="icon fa fa-calendar-o text-danger"></i><span class="post-date">11.05.2016</span>
	<i class="icon fa fa-tags text-success"></i><p class="entry-tags">
  	
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#ios" title="Pages tagged ios" rel="tag" class="text-success">ios</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#osx" title="Pages tagged osx" rel="tag" class="text-success">osx</a>
        </div>
        &nbsp;
      
  	  <div class="label bg-success">
  	    <a href="http://mrdekk.ru/tags/#xcode" title="Pages tagged xcode" rel="tag" class="text-success">xcode</a>
        </div>
        
      
    </p>

    <p>Допустим вам надо понять что случилось с приложением и у Вас есть крэш-дамп, однако на телефоне стоит iOS 6.1 которую xCode 7.3.1
принципиально знать не хочет и крэш-дампы с этого устройства не забирает. А смотреть надо. Для этого включаем iTunes и синхронизируем устройство,
тогда по пути</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">~/Library/Logs/CrashReporter/MobileDevice/</code></pre></figure>

<p>вы сможете найти крэш-дампы. После этого идем по пути</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/Applications/Xcode.app/Contents/SharedFrameworks/DTDeviceKitBase.framework/Versions/A/Resources</code></pre></figure>

<p>Для xCode 7.3 путь меняется</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">/Applications/Xcode7.3.1.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources</code></pre></figure>

<p>где лежит symbolicatecrash. Берем его и копируем вместе с *.crash файлом и *.ipa файлом (предварительно выключив опцию Strip Debug Symbols During Copy) после этого выполняем нехитрый скрипт</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">export </span><span class="nv">DEVELOPER_DIR</span><span class="o">=</span>/Applications/xCode6.4/Xcode6.4.app/Contents/Developer
<span class="nv">$ </span>./symbolicatecrash <span class="nt">-v</span> superapp_2016-05-11-211803_superphone.crash superapp.ipa</code></pre></figure>


  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page8"><i class="fa fa-hand-o-left" ></i> назад</a>
  
  
    
      <a class="pagination-item newer" href="/page6">вперед <i class="fa fa-hand-o-right" ></i></a>
    
  
</div>

    </div>

	<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter13259782 = new Ya.Metrika({
                    id:13259782,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true,
                    webvisor:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/13259782" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

	<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-16734363-2', 'auto');
  ga('send', 'pageview');

</script>

    <script src="/public/js/tabs.js"></script>

  </body>
</html>
