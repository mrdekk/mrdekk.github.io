---
layout: post
title: Заметки об архитектуре приложений (iOS)
tags:
 - xcode
 - ios
 - architecture
 - swift
---

В последнее время часто стали появляться статьи о том, как же правильно строить архитектуру вашего iOS приложения. Много разного шума о том, что MVC - это не Model View Controller, а Massive View Controller. Стали появляться специализированные сайты, где авторы пытаются подробно разжовывать что и как вы должны делать, чтобы архитектура вашего приложения была правильная и всем было хорошо.

Небольшой реестр того, что заслуживает внимание

 - [Clean Swift, eng](http://clean-swift.com) - тут вам предлагают рецепты (в виде шаблонов xCode), которые помогут вам управлять архитектурой правильно. Основано на VIPER.
 - [Архитектурные паттерны в iOS, рус](https://habrahabr.ru/company/badoo/blog/281162/) - статья на хабре (переводная) где автор разбирает доступные архитектурные паттерны. Полезно почитать для понимания и знания того, что значит MV... (Model View Something)
 - [Clean Architecture, eng](https://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) - статья Uncle Bob - основоположника Clean Architecture на базе которого вырос VIPER.

И много еще разного, тут привел что мне самому показалось полезным. Архитектурный паттерн VIPER попытались реализовать и популяризировать. Вот [тут](https://github.com/rambler-ios/Generamba) ребята даже наваяли автогенератор классов-модулей для VIPER для вашего приложения на Swift.

Однако во всем этот шуме очень мало попыток разобраться и что называется "на пальцах" проработать эти вещи. Да, Clean Swift заслуживает внимания, но он на английском и там автор все таки пытается продвигать свои xCode шаблоны. Статья uncle bob заслуживает внимания, но требует ооооочень вдумчивого прочтения. Я на истину и "бронзу" не претендую, но все же представлю свою "видение" этого всего и попытаюсь насколько это можно говорить простым языком. Итак, приступим. Для начала картинка:

![ARCH](/media/images/iosarch/viper2.jpg)

Пояснение к объектам:

 - View - представление, то что непосредственно рисуется на экране. В терминах iOS - это все UIView. Вся задача этой компоненты - нарисоваться на экране правильно.
 - ViewController - контроллер представления, ответственнен за управление представлением, правильного заполнения его полей и является делегатом для событий от представления. В терминах iOS - это все UIViewController. Вся задача этой компоненты - управлять представлением, однако бизнес-логика не для этого слоя.
 - Interactor - компонента которая обрабатывает события, как пользовательские (пользователь нажал кнопку), так и системные (экран появился или вот-вот появится). В терминах iOS нет специального класса для этого, этот класс полностью в вашем ведении. Данные компонент обеспечивает также работу с источником данных и с компонентом маршрутизатора.
 - Presenter - компонент, обеспечивающий связь миров бизнес-логики и представления. Обеспечивает в том числе преобразование из слоя данных в слой представления (Entity -> ViewModel). Также делает представление-специфичную обработку данных (например, группировка для UITableView). В терминах iOS также нет особых классов для этого компонента.
 - Router - маршрутизатор, обеспечивает смену связки V.I.P. (View-Interactor-Presenter) и управляет глобальными вещами для приложения (настройки, авторизация, может быть некоторая обработка ошибок и т.д.). В терминах iOS также нету специального класса, но источником pushViewController:animated: должен быть именно маршрутизатор.

За кадром остались

 - Configurator, компонент который связывает все воедино и может быть точкой внедрения DI
 - Initializer, специальный объект, который дает вам точку входа для вызова конфигуратора, если вы работаете через Storyboard'ы например.

Кроме того, не все линии одинакового цвета, это тоже кой чего значит:

 - оранжевые линии - тесная связь UIView и UIViewController. С точки зрения ViewController'а в сторону View ("управляет") - хранит ссылки и обеспечивает настройку через вызовы сеттеров или просто функций. С точки зрения View в сторону ViewController'а ("события") - ViewController является делегатом для View и является первой точкой приема событий.
 - красные линии - преобразованные в специальные DataTransfer Objects (DTO) "события" от представления, которые должны быть обработаны бизнес-логикой (т.е. в нашем случае интерактором). Это могут быть как просто скалярные объекты (числа, строки и т.д.), так и простые  (POCO, Swift struct, ...) объекты. Главное чтоб эти объекты не организовывали протекающие абстракции.
 - синии линии - объекты, которые понимает интерактор, которые необходимо отобразить в слое представления. Интерактор по понятным причинам не может и не должен знать о том, как устроено представление, поэтому он передает презентеру объекты для того, чтобы презентер их правильно преобразовал и отобразил на представлении.
 - зеленые линии - объекты (ViewModel) представления, которые понимает контроллер и которые контроллер использует для настройки вьюшек.
 - черные линии - взаимодействие интерактора со специфичными сервисами (сеть, CoreData и т.д.) и передача команд маршрутизатору, когда команда находится в ведении маршрутизатора или какого-то другого интерактора.

Таким образом

 1. Представление (V), интерактор (I) и презентер (P) образуют цикл. Данные могут передаваться только в направлении указанном стрелочками. Благодаря тому, что поток данных однонаправленный, они могут быть иммутабельными, что хорошо сказывает на многопоточности например.
 2. Представление, интерактор и презентер напрямую друг о друге ничего не знают - они взаимодействуют через интерфейсы (на схеме обозначены зелеными квадратами). Это позволяет их заменять по отдельности, тестировать их по отдельности а также открывает путь к реализации паттерна DI в рамках конфигуратора.

To be continue...
(Статья будет пополняться, можете принять в этом участие)
